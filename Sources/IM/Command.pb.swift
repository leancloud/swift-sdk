// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: messages2.proto.orig
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum IMCommandType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case session // = 0
  case conv // = 1
  case direct // = 2
  case ack // = 3
  case rcp // = 4
  case unread // = 5
  case logs // = 6
  case error // = 7
  case login // = 8
  case data // = 9
  case room // = 10
  case read // = 11
  case presence // = 12
  case report // = 13
  case echo // = 14
  case loggedin // = 15
  case logout // = 16
  case loggedout // = 17
  case patch // = 18
  case pubsub // = 19
  case blacklist // = 20

  init() {
    self = .session
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .session
    case 1: self = .conv
    case 2: self = .direct
    case 3: self = .ack
    case 4: self = .rcp
    case 5: self = .unread
    case 6: self = .logs
    case 7: self = .error
    case 8: self = .login
    case 9: self = .data
    case 10: self = .room
    case 11: self = .read
    case 12: self = .presence
    case 13: self = .report
    case 14: self = .echo
    case 15: self = .loggedin
    case 16: self = .logout
    case 17: self = .loggedout
    case 18: self = .patch
    case 19: self = .pubsub
    case 20: self = .blacklist
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .session: return 0
    case .conv: return 1
    case .direct: return 2
    case .ack: return 3
    case .rcp: return 4
    case .unread: return 5
    case .logs: return 6
    case .error: return 7
    case .login: return 8
    case .data: return 9
    case .room: return 10
    case .read: return 11
    case .presence: return 12
    case .report: return 13
    case .echo: return 14
    case .loggedin: return 15
    case .logout: return 16
    case .loggedout: return 17
    case .patch: return 18
    case .pubsub: return 19
    case .blacklist: return 20
    }
  }

}

#if swift(>=4.2)

extension IMCommandType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum IMOpType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// session
  case `open` // = 1
  case add // = 2
  case remove // = 3
  case close // = 4
  case opened // = 5
  case closed // = 6
  case query // = 7
  case queryResult // = 8
  case conflict // = 9
  case added // = 10
  case removed // = 11
  case refresh // = 12
  case refreshed // = 13

  /// conv
  case start // = 30
  case started // = 31
  case joined // = 32
  case membersJoined // = 33

  /// add = 34; reuse session.add
  /// added = 35; reuse session.added
  /// remove = 37; reuse session.remove
  /// removed = 38; reuse session.removed
  case left // = 39
  case membersLeft // = 40

  ///  query = 41; reuse session.query
  case results // = 42
  case count // = 43
  case result // = 44
  case update // = 45
  case updated // = 46
  case mute // = 47
  case unmute // = 48
  case status // = 49
  case members // = 50
  case maxRead // = 51
  case isMember // = 52
  case memberInfoUpdate // = 53
  case memberInfoUpdated // = 54
  case memberInfoChanged // = 55

  /// room
  case join // = 80
  case invite // = 81
  case leave // = 82
  case kick // = 83
  case reject // = 84
  case invited // = 85

  ///  joined = 32; reuse the value in conv section
  ///  left = 39; reuse the value in conv section
  case kicked // = 86

  /// report
  case upload // = 100
  case uploaded // = 101

  /// pubsub
  case subscribe // = 120
  case subscribed // = 121
  case unsubscribe // = 122
  case unsubscribed // = 123
  case isSubscribed // = 124

  /// patch
  case modify // = 150
  case modified // = 151

  /// blacklist, query, query_result defined with 7, 8
  case block // = 170
  case unblock // = 171
  case blocked // = 172
  case unblocked // = 173
  case membersBlocked // = 174
  case membersUnblocked // = 175
  case addShutup // = 180
  case removeShutup // = 181
  case queryShutup // = 182
  case shutupAdded // = 183
  case shutupRemoved // = 184
  case shutupResult // = 185
  case shutuped // = 186
  case unshutuped // = 187
  case membersShutuped // = 188
  case membersUnshutuped // = 189

  init() {
    self = .open
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .open
    case 2: self = .add
    case 3: self = .remove
    case 4: self = .close
    case 5: self = .opened
    case 6: self = .closed
    case 7: self = .query
    case 8: self = .queryResult
    case 9: self = .conflict
    case 10: self = .added
    case 11: self = .removed
    case 12: self = .refresh
    case 13: self = .refreshed
    case 30: self = .start
    case 31: self = .started
    case 32: self = .joined
    case 33: self = .membersJoined
    case 39: self = .left
    case 40: self = .membersLeft
    case 42: self = .results
    case 43: self = .count
    case 44: self = .result
    case 45: self = .update
    case 46: self = .updated
    case 47: self = .mute
    case 48: self = .unmute
    case 49: self = .status
    case 50: self = .members
    case 51: self = .maxRead
    case 52: self = .isMember
    case 53: self = .memberInfoUpdate
    case 54: self = .memberInfoUpdated
    case 55: self = .memberInfoChanged
    case 80: self = .join
    case 81: self = .invite
    case 82: self = .leave
    case 83: self = .kick
    case 84: self = .reject
    case 85: self = .invited
    case 86: self = .kicked
    case 100: self = .upload
    case 101: self = .uploaded
    case 120: self = .subscribe
    case 121: self = .subscribed
    case 122: self = .unsubscribe
    case 123: self = .unsubscribed
    case 124: self = .isSubscribed
    case 150: self = .modify
    case 151: self = .modified
    case 170: self = .block
    case 171: self = .unblock
    case 172: self = .blocked
    case 173: self = .unblocked
    case 174: self = .membersBlocked
    case 175: self = .membersUnblocked
    case 180: self = .addShutup
    case 181: self = .removeShutup
    case 182: self = .queryShutup
    case 183: self = .shutupAdded
    case 184: self = .shutupRemoved
    case 185: self = .shutupResult
    case 186: self = .shutuped
    case 187: self = .unshutuped
    case 188: self = .membersShutuped
    case 189: self = .membersUnshutuped
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .open: return 1
    case .add: return 2
    case .remove: return 3
    case .close: return 4
    case .opened: return 5
    case .closed: return 6
    case .query: return 7
    case .queryResult: return 8
    case .conflict: return 9
    case .added: return 10
    case .removed: return 11
    case .refresh: return 12
    case .refreshed: return 13
    case .start: return 30
    case .started: return 31
    case .joined: return 32
    case .membersJoined: return 33
    case .left: return 39
    case .membersLeft: return 40
    case .results: return 42
    case .count: return 43
    case .result: return 44
    case .update: return 45
    case .updated: return 46
    case .mute: return 47
    case .unmute: return 48
    case .status: return 49
    case .members: return 50
    case .maxRead: return 51
    case .isMember: return 52
    case .memberInfoUpdate: return 53
    case .memberInfoUpdated: return 54
    case .memberInfoChanged: return 55
    case .join: return 80
    case .invite: return 81
    case .leave: return 82
    case .kick: return 83
    case .reject: return 84
    case .invited: return 85
    case .kicked: return 86
    case .upload: return 100
    case .uploaded: return 101
    case .subscribe: return 120
    case .subscribed: return 121
    case .unsubscribe: return 122
    case .unsubscribed: return 123
    case .isSubscribed: return 124
    case .modify: return 150
    case .modified: return 151
    case .block: return 170
    case .unblock: return 171
    case .blocked: return 172
    case .unblocked: return 173
    case .membersBlocked: return 174
    case .membersUnblocked: return 175
    case .addShutup: return 180
    case .removeShutup: return 181
    case .queryShutup: return 182
    case .shutupAdded: return 183
    case .shutupRemoved: return 184
    case .shutupResult: return 185
    case .shutuped: return 186
    case .unshutuped: return 187
    case .membersShutuped: return 188
    case .membersUnshutuped: return 189
    }
  }

}

#if swift(>=4.2)

extension IMOpType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum IMStatusType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case on // = 1
  case off // = 2

  init() {
    self = .on
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .on
    case 2: self = .off
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .on: return 1
    case .off: return 2
    }
  }

}

#if swift(>=4.2)

extension IMStatusType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct IMJsonObjectMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: String {
    get {return _data ?? String()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _data: String? = nil
}

struct IMUnreadTuple {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cid: String {
    get {return _cid ?? String()}
    set {_cid = newValue}
  }
  /// Returns true if `cid` has been explicitly set.
  var hasCid: Bool {return self._cid != nil}
  /// Clears the value of `cid`. Subsequent reads from it will return its default value.
  mutating func clearCid() {self._cid = nil}

  var unread: Int32 {
    get {return _unread ?? 0}
    set {_unread = newValue}
  }
  /// Returns true if `unread` has been explicitly set.
  var hasUnread: Bool {return self._unread != nil}
  /// Clears the value of `unread`. Subsequent reads from it will return its default value.
  mutating func clearUnread() {self._unread = nil}

  var mid: String {
    get {return _mid ?? String()}
    set {_mid = newValue}
  }
  /// Returns true if `mid` has been explicitly set.
  var hasMid: Bool {return self._mid != nil}
  /// Clears the value of `mid`. Subsequent reads from it will return its default value.
  mutating func clearMid() {self._mid = nil}

  var timestamp: Int64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var from: String {
    get {return _from ?? String()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  mutating func clearFrom() {self._from = nil}

  var data: String {
    get {return _data ?? String()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  var patchTimestamp: Int64 {
    get {return _patchTimestamp ?? 0}
    set {_patchTimestamp = newValue}
  }
  /// Returns true if `patchTimestamp` has been explicitly set.
  var hasPatchTimestamp: Bool {return self._patchTimestamp != nil}
  /// Clears the value of `patchTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearPatchTimestamp() {self._patchTimestamp = nil}

  var mentioned: Bool {
    get {return _mentioned ?? false}
    set {_mentioned = newValue}
  }
  /// Returns true if `mentioned` has been explicitly set.
  var hasMentioned: Bool {return self._mentioned != nil}
  /// Clears the value of `mentioned`. Subsequent reads from it will return its default value.
  mutating func clearMentioned() {self._mentioned = nil}

  var binaryMsg: Data {
    get {return _binaryMsg ?? SwiftProtobuf.Internal.emptyData}
    set {_binaryMsg = newValue}
  }
  /// Returns true if `binaryMsg` has been explicitly set.
  var hasBinaryMsg: Bool {return self._binaryMsg != nil}
  /// Clears the value of `binaryMsg`. Subsequent reads from it will return its default value.
  mutating func clearBinaryMsg() {self._binaryMsg = nil}

  var convType: Int32 {
    get {return _convType ?? 0}
    set {_convType = newValue}
  }
  /// Returns true if `convType` has been explicitly set.
  var hasConvType: Bool {return self._convType != nil}
  /// Clears the value of `convType`. Subsequent reads from it will return its default value.
  mutating func clearConvType() {self._convType = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cid: String? = nil
  fileprivate var _unread: Int32? = nil
  fileprivate var _mid: String? = nil
  fileprivate var _timestamp: Int64? = nil
  fileprivate var _from: String? = nil
  fileprivate var _data: String? = nil
  fileprivate var _patchTimestamp: Int64? = nil
  fileprivate var _mentioned: Bool? = nil
  fileprivate var _binaryMsg: Data? = nil
  fileprivate var _convType: Int32? = nil
}

struct IMLogItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var from: String {
    get {return _from ?? String()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  mutating func clearFrom() {self._from = nil}

  var data: String {
    get {return _data ?? String()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  var timestamp: Int64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var msgID: String {
    get {return _msgID ?? String()}
    set {_msgID = newValue}
  }
  /// Returns true if `msgID` has been explicitly set.
  var hasMsgID: Bool {return self._msgID != nil}
  /// Clears the value of `msgID`. Subsequent reads from it will return its default value.
  mutating func clearMsgID() {self._msgID = nil}

  var ackAt: Int64 {
    get {return _ackAt ?? 0}
    set {_ackAt = newValue}
  }
  /// Returns true if `ackAt` has been explicitly set.
  var hasAckAt: Bool {return self._ackAt != nil}
  /// Clears the value of `ackAt`. Subsequent reads from it will return its default value.
  mutating func clearAckAt() {self._ackAt = nil}

  var readAt: Int64 {
    get {return _readAt ?? 0}
    set {_readAt = newValue}
  }
  /// Returns true if `readAt` has been explicitly set.
  var hasReadAt: Bool {return self._readAt != nil}
  /// Clears the value of `readAt`. Subsequent reads from it will return its default value.
  mutating func clearReadAt() {self._readAt = nil}

  var patchTimestamp: Int64 {
    get {return _patchTimestamp ?? 0}
    set {_patchTimestamp = newValue}
  }
  /// Returns true if `patchTimestamp` has been explicitly set.
  var hasPatchTimestamp: Bool {return self._patchTimestamp != nil}
  /// Clears the value of `patchTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearPatchTimestamp() {self._patchTimestamp = nil}

  var mentionAll: Bool {
    get {return _mentionAll ?? false}
    set {_mentionAll = newValue}
  }
  /// Returns true if `mentionAll` has been explicitly set.
  var hasMentionAll: Bool {return self._mentionAll != nil}
  /// Clears the value of `mentionAll`. Subsequent reads from it will return its default value.
  mutating func clearMentionAll() {self._mentionAll = nil}

  var mentionPids: [String] = []

  var bin: Bool {
    get {return _bin ?? false}
    set {_bin = newValue}
  }
  /// Returns true if `bin` has been explicitly set.
  var hasBin: Bool {return self._bin != nil}
  /// Clears the value of `bin`. Subsequent reads from it will return its default value.
  mutating func clearBin() {self._bin = nil}

  var convType: Int32 {
    get {return _convType ?? 0}
    set {_convType = newValue}
  }
  /// Returns true if `convType` has been explicitly set.
  var hasConvType: Bool {return self._convType != nil}
  /// Clears the value of `convType`. Subsequent reads from it will return its default value.
  mutating func clearConvType() {self._convType = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _from: String? = nil
  fileprivate var _data: String? = nil
  fileprivate var _timestamp: Int64? = nil
  fileprivate var _msgID: String? = nil
  fileprivate var _ackAt: Int64? = nil
  fileprivate var _readAt: Int64? = nil
  fileprivate var _patchTimestamp: Int64? = nil
  fileprivate var _mentionAll: Bool? = nil
  fileprivate var _bin: Bool? = nil
  fileprivate var _convType: Int32? = nil
}

struct IMConvMemberInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pid: String {
    get {return _pid ?? String()}
    set {_pid = newValue}
  }
  /// Returns true if `pid` has been explicitly set.
  var hasPid: Bool {return self._pid != nil}
  /// Clears the value of `pid`. Subsequent reads from it will return its default value.
  mutating func clearPid() {self._pid = nil}

  var role: String {
    get {return _role ?? String()}
    set {_role = newValue}
  }
  /// Returns true if `role` has been explicitly set.
  var hasRole: Bool {return self._role != nil}
  /// Clears the value of `role`. Subsequent reads from it will return its default value.
  mutating func clearRole() {self._role = nil}

  var infoID: String {
    get {return _infoID ?? String()}
    set {_infoID = newValue}
  }
  /// Returns true if `infoID` has been explicitly set.
  var hasInfoID: Bool {return self._infoID != nil}
  /// Clears the value of `infoID`. Subsequent reads from it will return its default value.
  mutating func clearInfoID() {self._infoID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pid: String? = nil
  fileprivate var _role: String? = nil
  fileprivate var _infoID: String? = nil
}

struct IMDataCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ids: [String] = []

  var msg: [IMJsonObjectMessage] = []

  var offline: Bool {
    get {return _offline ?? false}
    set {_offline = newValue}
  }
  /// Returns true if `offline` has been explicitly set.
  var hasOffline: Bool {return self._offline != nil}
  /// Clears the value of `offline`. Subsequent reads from it will return its default value.
  mutating func clearOffline() {self._offline = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _offline: Bool? = nil
}

struct IMSessionCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var t: Int64 {
    get {return _storage._t ?? 0}
    set {_uniqueStorage()._t = newValue}
  }
  /// Returns true if `t` has been explicitly set.
  var hasT: Bool {return _storage._t != nil}
  /// Clears the value of `t`. Subsequent reads from it will return its default value.
  mutating func clearT() {_uniqueStorage()._t = nil}

  var n: String {
    get {return _storage._n ?? String()}
    set {_uniqueStorage()._n = newValue}
  }
  /// Returns true if `n` has been explicitly set.
  var hasN: Bool {return _storage._n != nil}
  /// Clears the value of `n`. Subsequent reads from it will return its default value.
  mutating func clearN() {_uniqueStorage()._n = nil}

  var s: String {
    get {return _storage._s ?? String()}
    set {_uniqueStorage()._s = newValue}
  }
  /// Returns true if `s` has been explicitly set.
  var hasS: Bool {return _storage._s != nil}
  /// Clears the value of `s`. Subsequent reads from it will return its default value.
  mutating func clearS() {_uniqueStorage()._s = nil}

  var ua: String {
    get {return _storage._ua ?? String()}
    set {_uniqueStorage()._ua = newValue}
  }
  /// Returns true if `ua` has been explicitly set.
  var hasUa: Bool {return _storage._ua != nil}
  /// Clears the value of `ua`. Subsequent reads from it will return its default value.
  mutating func clearUa() {_uniqueStorage()._ua = nil}

  var r: Bool {
    get {return _storage._r ?? false}
    set {_uniqueStorage()._r = newValue}
  }
  /// Returns true if `r` has been explicitly set.
  var hasR: Bool {return _storage._r != nil}
  /// Clears the value of `r`. Subsequent reads from it will return its default value.
  mutating func clearR() {_uniqueStorage()._r = nil}

  var tag: String {
    get {return _storage._tag ?? String()}
    set {_uniqueStorage()._tag = newValue}
  }
  /// Returns true if `tag` has been explicitly set.
  var hasTag: Bool {return _storage._tag != nil}
  /// Clears the value of `tag`. Subsequent reads from it will return its default value.
  mutating func clearTag() {_uniqueStorage()._tag = nil}

  var deviceID: String {
    get {return _storage._deviceID ?? String()}
    set {_uniqueStorage()._deviceID = newValue}
  }
  /// Returns true if `deviceID` has been explicitly set.
  var hasDeviceID: Bool {return _storage._deviceID != nil}
  /// Clears the value of `deviceID`. Subsequent reads from it will return its default value.
  mutating func clearDeviceID() {_uniqueStorage()._deviceID = nil}

  var sessionPeerIds: [String] {
    get {return _storage._sessionPeerIds}
    set {_uniqueStorage()._sessionPeerIds = newValue}
  }

  var onlineSessionPeerIds: [String] {
    get {return _storage._onlineSessionPeerIds}
    set {_uniqueStorage()._onlineSessionPeerIds = newValue}
  }

  var st: String {
    get {return _storage._st ?? String()}
    set {_uniqueStorage()._st = newValue}
  }
  /// Returns true if `st` has been explicitly set.
  var hasSt: Bool {return _storage._st != nil}
  /// Clears the value of `st`. Subsequent reads from it will return its default value.
  mutating func clearSt() {_uniqueStorage()._st = nil}

  var stTtl: Int32 {
    get {return _storage._stTtl ?? 0}
    set {_uniqueStorage()._stTtl = newValue}
  }
  /// Returns true if `stTtl` has been explicitly set.
  var hasStTtl: Bool {return _storage._stTtl != nil}
  /// Clears the value of `stTtl`. Subsequent reads from it will return its default value.
  mutating func clearStTtl() {_uniqueStorage()._stTtl = nil}

  var code: Int32 {
    get {return _storage._code ?? 0}
    set {_uniqueStorage()._code = newValue}
  }
  /// Returns true if `code` has been explicitly set.
  var hasCode: Bool {return _storage._code != nil}
  /// Clears the value of `code`. Subsequent reads from it will return its default value.
  mutating func clearCode() {_uniqueStorage()._code = nil}

  var reason: String {
    get {return _storage._reason ?? String()}
    set {_uniqueStorage()._reason = newValue}
  }
  /// Returns true if `reason` has been explicitly set.
  var hasReason: Bool {return _storage._reason != nil}
  /// Clears the value of `reason`. Subsequent reads from it will return its default value.
  mutating func clearReason() {_uniqueStorage()._reason = nil}

  var deviceToken: String {
    get {return _storage._deviceToken ?? String()}
    set {_uniqueStorage()._deviceToken = newValue}
  }
  /// Returns true if `deviceToken` has been explicitly set.
  var hasDeviceToken: Bool {return _storage._deviceToken != nil}
  /// Clears the value of `deviceToken`. Subsequent reads from it will return its default value.
  mutating func clearDeviceToken() {_uniqueStorage()._deviceToken = nil}

  var sp: Bool {
    get {return _storage._sp ?? false}
    set {_uniqueStorage()._sp = newValue}
  }
  /// Returns true if `sp` has been explicitly set.
  var hasSp: Bool {return _storage._sp != nil}
  /// Clears the value of `sp`. Subsequent reads from it will return its default value.
  mutating func clearSp() {_uniqueStorage()._sp = nil}

  var detail: String {
    get {return _storage._detail ?? String()}
    set {_uniqueStorage()._detail = newValue}
  }
  /// Returns true if `detail` has been explicitly set.
  var hasDetail: Bool {return _storage._detail != nil}
  /// Clears the value of `detail`. Subsequent reads from it will return its default value.
  mutating func clearDetail() {_uniqueStorage()._detail = nil}

  var lastUnreadNotifTime: Int64 {
    get {return _storage._lastUnreadNotifTime ?? 0}
    set {_uniqueStorage()._lastUnreadNotifTime = newValue}
  }
  /// Returns true if `lastUnreadNotifTime` has been explicitly set.
  var hasLastUnreadNotifTime: Bool {return _storage._lastUnreadNotifTime != nil}
  /// Clears the value of `lastUnreadNotifTime`. Subsequent reads from it will return its default value.
  mutating func clearLastUnreadNotifTime() {_uniqueStorage()._lastUnreadNotifTime = nil}

  var lastPatchTime: Int64 {
    get {return _storage._lastPatchTime ?? 0}
    set {_uniqueStorage()._lastPatchTime = newValue}
  }
  /// Returns true if `lastPatchTime` has been explicitly set.
  var hasLastPatchTime: Bool {return _storage._lastPatchTime != nil}
  /// Clears the value of `lastPatchTime`. Subsequent reads from it will return its default value.
  mutating func clearLastPatchTime() {_uniqueStorage()._lastPatchTime = nil}

  var configBitmap: Int64 {
    get {return _storage._configBitmap ?? 0}
    set {_uniqueStorage()._configBitmap = newValue}
  }
  /// Returns true if `configBitmap` has been explicitly set.
  var hasConfigBitmap: Bool {return _storage._configBitmap != nil}
  /// Clears the value of `configBitmap`. Subsequent reads from it will return its default value.
  mutating func clearConfigBitmap() {_uniqueStorage()._configBitmap = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct IMErrorCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: Int32 {
    get {return _code ?? 0}
    set {_code = newValue}
  }
  /// Returns true if `code` has been explicitly set.
  var hasCode: Bool {return self._code != nil}
  /// Clears the value of `code`. Subsequent reads from it will return its default value.
  mutating func clearCode() {self._code = nil}

  var reason: String {
    get {return _reason ?? String()}
    set {_reason = newValue}
  }
  /// Returns true if `reason` has been explicitly set.
  var hasReason: Bool {return self._reason != nil}
  /// Clears the value of `reason`. Subsequent reads from it will return its default value.
  mutating func clearReason() {self._reason = nil}

  var appCode: Int32 {
    get {return _appCode ?? 0}
    set {_appCode = newValue}
  }
  /// Returns true if `appCode` has been explicitly set.
  var hasAppCode: Bool {return self._appCode != nil}
  /// Clears the value of `appCode`. Subsequent reads from it will return its default value.
  mutating func clearAppCode() {self._appCode = nil}

  var detail: String {
    get {return _detail ?? String()}
    set {_detail = newValue}
  }
  /// Returns true if `detail` has been explicitly set.
  var hasDetail: Bool {return self._detail != nil}
  /// Clears the value of `detail`. Subsequent reads from it will return its default value.
  mutating func clearDetail() {self._detail = nil}

  var pids: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _code: Int32? = nil
  fileprivate var _reason: String? = nil
  fileprivate var _appCode: Int32? = nil
  fileprivate var _detail: String? = nil
}

struct IMDirectCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var msg: String {
    get {return _storage._msg ?? String()}
    set {_uniqueStorage()._msg = newValue}
  }
  /// Returns true if `msg` has been explicitly set.
  var hasMsg: Bool {return _storage._msg != nil}
  /// Clears the value of `msg`. Subsequent reads from it will return its default value.
  mutating func clearMsg() {_uniqueStorage()._msg = nil}

  var uid: String {
    get {return _storage._uid ?? String()}
    set {_uniqueStorage()._uid = newValue}
  }
  /// Returns true if `uid` has been explicitly set.
  var hasUid: Bool {return _storage._uid != nil}
  /// Clears the value of `uid`. Subsequent reads from it will return its default value.
  mutating func clearUid() {_uniqueStorage()._uid = nil}

  var fromPeerID: String {
    get {return _storage._fromPeerID ?? String()}
    set {_uniqueStorage()._fromPeerID = newValue}
  }
  /// Returns true if `fromPeerID` has been explicitly set.
  var hasFromPeerID: Bool {return _storage._fromPeerID != nil}
  /// Clears the value of `fromPeerID`. Subsequent reads from it will return its default value.
  mutating func clearFromPeerID() {_uniqueStorage()._fromPeerID = nil}

  var timestamp: Int64 {
    get {return _storage._timestamp ?? 0}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  var offline: Bool {
    get {return _storage._offline ?? false}
    set {_uniqueStorage()._offline = newValue}
  }
  /// Returns true if `offline` has been explicitly set.
  var hasOffline: Bool {return _storage._offline != nil}
  /// Clears the value of `offline`. Subsequent reads from it will return its default value.
  mutating func clearOffline() {_uniqueStorage()._offline = nil}

  var hasMore_p: Bool {
    get {return _storage._hasMore_p ?? false}
    set {_uniqueStorage()._hasMore_p = newValue}
  }
  /// Returns true if `hasMore_p` has been explicitly set.
  var hasHasMore_p: Bool {return _storage._hasMore_p != nil}
  /// Clears the value of `hasMore_p`. Subsequent reads from it will return its default value.
  mutating func clearHasMore_p() {_uniqueStorage()._hasMore_p = nil}

  var toPeerIds: [String] {
    get {return _storage._toPeerIds}
    set {_uniqueStorage()._toPeerIds = newValue}
  }

  var r: Bool {
    get {return _storage._r ?? false}
    set {_uniqueStorage()._r = newValue}
  }
  /// Returns true if `r` has been explicitly set.
  var hasR: Bool {return _storage._r != nil}
  /// Clears the value of `r`. Subsequent reads from it will return its default value.
  mutating func clearR() {_uniqueStorage()._r = nil}

  var cid: String {
    get {return _storage._cid ?? String()}
    set {_uniqueStorage()._cid = newValue}
  }
  /// Returns true if `cid` has been explicitly set.
  var hasCid: Bool {return _storage._cid != nil}
  /// Clears the value of `cid`. Subsequent reads from it will return its default value.
  mutating func clearCid() {_uniqueStorage()._cid = nil}

  var id: String {
    get {return _storage._id ?? String()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {_uniqueStorage()._id = nil}

  var transient: Bool {
    get {return _storage._transient ?? false}
    set {_uniqueStorage()._transient = newValue}
  }
  /// Returns true if `transient` has been explicitly set.
  var hasTransient: Bool {return _storage._transient != nil}
  /// Clears the value of `transient`. Subsequent reads from it will return its default value.
  mutating func clearTransient() {_uniqueStorage()._transient = nil}

  var dt: String {
    get {return _storage._dt ?? String()}
    set {_uniqueStorage()._dt = newValue}
  }
  /// Returns true if `dt` has been explicitly set.
  var hasDt: Bool {return _storage._dt != nil}
  /// Clears the value of `dt`. Subsequent reads from it will return its default value.
  mutating func clearDt() {_uniqueStorage()._dt = nil}

  var roomID: String {
    get {return _storage._roomID ?? String()}
    set {_uniqueStorage()._roomID = newValue}
  }
  /// Returns true if `roomID` has been explicitly set.
  var hasRoomID: Bool {return _storage._roomID != nil}
  /// Clears the value of `roomID`. Subsequent reads from it will return its default value.
  mutating func clearRoomID() {_uniqueStorage()._roomID = nil}

  var pushData: String {
    get {return _storage._pushData ?? String()}
    set {_uniqueStorage()._pushData = newValue}
  }
  /// Returns true if `pushData` has been explicitly set.
  var hasPushData: Bool {return _storage._pushData != nil}
  /// Clears the value of `pushData`. Subsequent reads from it will return its default value.
  mutating func clearPushData() {_uniqueStorage()._pushData = nil}

  var will: Bool {
    get {return _storage._will ?? false}
    set {_uniqueStorage()._will = newValue}
  }
  /// Returns true if `will` has been explicitly set.
  var hasWill: Bool {return _storage._will != nil}
  /// Clears the value of `will`. Subsequent reads from it will return its default value.
  mutating func clearWill() {_uniqueStorage()._will = nil}

  var patchTimestamp: Int64 {
    get {return _storage._patchTimestamp ?? 0}
    set {_uniqueStorage()._patchTimestamp = newValue}
  }
  /// Returns true if `patchTimestamp` has been explicitly set.
  var hasPatchTimestamp: Bool {return _storage._patchTimestamp != nil}
  /// Clears the value of `patchTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearPatchTimestamp() {_uniqueStorage()._patchTimestamp = nil}

  var binaryMsg: Data {
    get {return _storage._binaryMsg ?? SwiftProtobuf.Internal.emptyData}
    set {_uniqueStorage()._binaryMsg = newValue}
  }
  /// Returns true if `binaryMsg` has been explicitly set.
  var hasBinaryMsg: Bool {return _storage._binaryMsg != nil}
  /// Clears the value of `binaryMsg`. Subsequent reads from it will return its default value.
  mutating func clearBinaryMsg() {_uniqueStorage()._binaryMsg = nil}

  var mentionPids: [String] {
    get {return _storage._mentionPids}
    set {_uniqueStorage()._mentionPids = newValue}
  }

  var mentionAll: Bool {
    get {return _storage._mentionAll ?? false}
    set {_uniqueStorage()._mentionAll = newValue}
  }
  /// Returns true if `mentionAll` has been explicitly set.
  var hasMentionAll: Bool {return _storage._mentionAll != nil}
  /// Clears the value of `mentionAll`. Subsequent reads from it will return its default value.
  mutating func clearMentionAll() {_uniqueStorage()._mentionAll = nil}

  var convType: Int32 {
    get {return _storage._convType ?? 0}
    set {_uniqueStorage()._convType = newValue}
  }
  /// Returns true if `convType` has been explicitly set.
  var hasConvType: Bool {return _storage._convType != nil}
  /// Clears the value of `convType`. Subsequent reads from it will return its default value.
  mutating func clearConvType() {_uniqueStorage()._convType = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct IMAckCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: Int32 {
    get {return _code ?? 0}
    set {_code = newValue}
  }
  /// Returns true if `code` has been explicitly set.
  var hasCode: Bool {return self._code != nil}
  /// Clears the value of `code`. Subsequent reads from it will return its default value.
  mutating func clearCode() {self._code = nil}

  var reason: String {
    get {return _reason ?? String()}
    set {_reason = newValue}
  }
  /// Returns true if `reason` has been explicitly set.
  var hasReason: Bool {return self._reason != nil}
  /// Clears the value of `reason`. Subsequent reads from it will return its default value.
  mutating func clearReason() {self._reason = nil}

  var mid: String {
    get {return _mid ?? String()}
    set {_mid = newValue}
  }
  /// Returns true if `mid` has been explicitly set.
  var hasMid: Bool {return self._mid != nil}
  /// Clears the value of `mid`. Subsequent reads from it will return its default value.
  mutating func clearMid() {self._mid = nil}

  var cid: String {
    get {return _cid ?? String()}
    set {_cid = newValue}
  }
  /// Returns true if `cid` has been explicitly set.
  var hasCid: Bool {return self._cid != nil}
  /// Clears the value of `cid`. Subsequent reads from it will return its default value.
  mutating func clearCid() {self._cid = nil}

  var t: Int64 {
    get {return _t ?? 0}
    set {_t = newValue}
  }
  /// Returns true if `t` has been explicitly set.
  var hasT: Bool {return self._t != nil}
  /// Clears the value of `t`. Subsequent reads from it will return its default value.
  mutating func clearT() {self._t = nil}

  var uid: String {
    get {return _uid ?? String()}
    set {_uid = newValue}
  }
  /// Returns true if `uid` has been explicitly set.
  var hasUid: Bool {return self._uid != nil}
  /// Clears the value of `uid`. Subsequent reads from it will return its default value.
  mutating func clearUid() {self._uid = nil}

  var fromts: Int64 {
    get {return _fromts ?? 0}
    set {_fromts = newValue}
  }
  /// Returns true if `fromts` has been explicitly set.
  var hasFromts: Bool {return self._fromts != nil}
  /// Clears the value of `fromts`. Subsequent reads from it will return its default value.
  mutating func clearFromts() {self._fromts = nil}

  var tots: Int64 {
    get {return _tots ?? 0}
    set {_tots = newValue}
  }
  /// Returns true if `tots` has been explicitly set.
  var hasTots: Bool {return self._tots != nil}
  /// Clears the value of `tots`. Subsequent reads from it will return its default value.
  mutating func clearTots() {self._tots = nil}

  var type: String {
    get {return _type ?? String()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var ids: [String] = []

  var appCode: Int32 {
    get {return _appCode ?? 0}
    set {_appCode = newValue}
  }
  /// Returns true if `appCode` has been explicitly set.
  var hasAppCode: Bool {return self._appCode != nil}
  /// Clears the value of `appCode`. Subsequent reads from it will return its default value.
  mutating func clearAppCode() {self._appCode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _code: Int32? = nil
  fileprivate var _reason: String? = nil
  fileprivate var _mid: String? = nil
  fileprivate var _cid: String? = nil
  fileprivate var _t: Int64? = nil
  fileprivate var _uid: String? = nil
  fileprivate var _fromts: Int64? = nil
  fileprivate var _tots: Int64? = nil
  fileprivate var _type: String? = nil
  fileprivate var _appCode: Int32? = nil
}

struct IMUnreadCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var convs: [IMUnreadTuple] = []

  var notifTime: Int64 {
    get {return _notifTime ?? 0}
    set {_notifTime = newValue}
  }
  /// Returns true if `notifTime` has been explicitly set.
  var hasNotifTime: Bool {return self._notifTime != nil}
  /// Clears the value of `notifTime`. Subsequent reads from it will return its default value.
  mutating func clearNotifTime() {self._notifTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _notifTime: Int64? = nil
}

struct IMConvCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var m: [String] {
    get {return _storage._m}
    set {_uniqueStorage()._m = newValue}
  }

  var transient: Bool {
    get {return _storage._transient ?? false}
    set {_uniqueStorage()._transient = newValue}
  }
  /// Returns true if `transient` has been explicitly set.
  var hasTransient: Bool {return _storage._transient != nil}
  /// Clears the value of `transient`. Subsequent reads from it will return its default value.
  mutating func clearTransient() {_uniqueStorage()._transient = nil}

  var unique: Bool {
    get {return _storage._unique ?? false}
    set {_uniqueStorage()._unique = newValue}
  }
  /// Returns true if `unique` has been explicitly set.
  var hasUnique: Bool {return _storage._unique != nil}
  /// Clears the value of `unique`. Subsequent reads from it will return its default value.
  mutating func clearUnique() {_uniqueStorage()._unique = nil}

  var cid: String {
    get {return _storage._cid ?? String()}
    set {_uniqueStorage()._cid = newValue}
  }
  /// Returns true if `cid` has been explicitly set.
  var hasCid: Bool {return _storage._cid != nil}
  /// Clears the value of `cid`. Subsequent reads from it will return its default value.
  mutating func clearCid() {_uniqueStorage()._cid = nil}

  var cdate: String {
    get {return _storage._cdate ?? String()}
    set {_uniqueStorage()._cdate = newValue}
  }
  /// Returns true if `cdate` has been explicitly set.
  var hasCdate: Bool {return _storage._cdate != nil}
  /// Clears the value of `cdate`. Subsequent reads from it will return its default value.
  mutating func clearCdate() {_uniqueStorage()._cdate = nil}

  var initBy: String {
    get {return _storage._initBy ?? String()}
    set {_uniqueStorage()._initBy = newValue}
  }
  /// Returns true if `initBy` has been explicitly set.
  var hasInitBy: Bool {return _storage._initBy != nil}
  /// Clears the value of `initBy`. Subsequent reads from it will return its default value.
  mutating func clearInitBy() {_uniqueStorage()._initBy = nil}

  var sort: String {
    get {return _storage._sort ?? String()}
    set {_uniqueStorage()._sort = newValue}
  }
  /// Returns true if `sort` has been explicitly set.
  var hasSort: Bool {return _storage._sort != nil}
  /// Clears the value of `sort`. Subsequent reads from it will return its default value.
  mutating func clearSort() {_uniqueStorage()._sort = nil}

  var limit: Int32 {
    get {return _storage._limit ?? 0}
    set {_uniqueStorage()._limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  var hasLimit: Bool {return _storage._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  mutating func clearLimit() {_uniqueStorage()._limit = nil}

  var skip: Int32 {
    get {return _storage._skip ?? 0}
    set {_uniqueStorage()._skip = newValue}
  }
  /// Returns true if `skip` has been explicitly set.
  var hasSkip: Bool {return _storage._skip != nil}
  /// Clears the value of `skip`. Subsequent reads from it will return its default value.
  mutating func clearSkip() {_uniqueStorage()._skip = nil}

  var flag: Int32 {
    get {return _storage._flag ?? 0}
    set {_uniqueStorage()._flag = newValue}
  }
  /// Returns true if `flag` has been explicitly set.
  var hasFlag: Bool {return _storage._flag != nil}
  /// Clears the value of `flag`. Subsequent reads from it will return its default value.
  mutating func clearFlag() {_uniqueStorage()._flag = nil}

  var count: Int32 {
    get {return _storage._count ?? 0}
    set {_uniqueStorage()._count = newValue}
  }
  /// Returns true if `count` has been explicitly set.
  var hasCount: Bool {return _storage._count != nil}
  /// Clears the value of `count`. Subsequent reads from it will return its default value.
  mutating func clearCount() {_uniqueStorage()._count = nil}

  var udate: String {
    get {return _storage._udate ?? String()}
    set {_uniqueStorage()._udate = newValue}
  }
  /// Returns true if `udate` has been explicitly set.
  var hasUdate: Bool {return _storage._udate != nil}
  /// Clears the value of `udate`. Subsequent reads from it will return its default value.
  mutating func clearUdate() {_uniqueStorage()._udate = nil}

  var t: Int64 {
    get {return _storage._t ?? 0}
    set {_uniqueStorage()._t = newValue}
  }
  /// Returns true if `t` has been explicitly set.
  var hasT: Bool {return _storage._t != nil}
  /// Clears the value of `t`. Subsequent reads from it will return its default value.
  mutating func clearT() {_uniqueStorage()._t = nil}

  var n: String {
    get {return _storage._n ?? String()}
    set {_uniqueStorage()._n = newValue}
  }
  /// Returns true if `n` has been explicitly set.
  var hasN: Bool {return _storage._n != nil}
  /// Clears the value of `n`. Subsequent reads from it will return its default value.
  mutating func clearN() {_uniqueStorage()._n = nil}

  var s: String {
    get {return _storage._s ?? String()}
    set {_uniqueStorage()._s = newValue}
  }
  /// Returns true if `s` has been explicitly set.
  var hasS: Bool {return _storage._s != nil}
  /// Clears the value of `s`. Subsequent reads from it will return its default value.
  mutating func clearS() {_uniqueStorage()._s = nil}

  var statusSub: Bool {
    get {return _storage._statusSub ?? false}
    set {_uniqueStorage()._statusSub = newValue}
  }
  /// Returns true if `statusSub` has been explicitly set.
  var hasStatusSub: Bool {return _storage._statusSub != nil}
  /// Clears the value of `statusSub`. Subsequent reads from it will return its default value.
  mutating func clearStatusSub() {_uniqueStorage()._statusSub = nil}

  var statusPub: Bool {
    get {return _storage._statusPub ?? false}
    set {_uniqueStorage()._statusPub = newValue}
  }
  /// Returns true if `statusPub` has been explicitly set.
  var hasStatusPub: Bool {return _storage._statusPub != nil}
  /// Clears the value of `statusPub`. Subsequent reads from it will return its default value.
  mutating func clearStatusPub() {_uniqueStorage()._statusPub = nil}

  var statusTtl: Int32 {
    get {return _storage._statusTtl ?? 0}
    set {_uniqueStorage()._statusTtl = newValue}
  }
  /// Returns true if `statusTtl` has been explicitly set.
  var hasStatusTtl: Bool {return _storage._statusTtl != nil}
  /// Clears the value of `statusTtl`. Subsequent reads from it will return its default value.
  mutating func clearStatusTtl() {_uniqueStorage()._statusTtl = nil}

  var uniqueID: String {
    get {return _storage._uniqueID ?? String()}
    set {_uniqueStorage()._uniqueID = newValue}
  }
  /// Returns true if `uniqueID` has been explicitly set.
  var hasUniqueID: Bool {return _storage._uniqueID != nil}
  /// Clears the value of `uniqueID`. Subsequent reads from it will return its default value.
  mutating func clearUniqueID() {_uniqueStorage()._uniqueID = nil}

  var targetClientID: String {
    get {return _storage._targetClientID ?? String()}
    set {_uniqueStorage()._targetClientID = newValue}
  }
  /// Returns true if `targetClientID` has been explicitly set.
  var hasTargetClientID: Bool {return _storage._targetClientID != nil}
  /// Clears the value of `targetClientID`. Subsequent reads from it will return its default value.
  mutating func clearTargetClientID() {_uniqueStorage()._targetClientID = nil}

  var maxReadTimestamp: Int64 {
    get {return _storage._maxReadTimestamp ?? 0}
    set {_uniqueStorage()._maxReadTimestamp = newValue}
  }
  /// Returns true if `maxReadTimestamp` has been explicitly set.
  var hasMaxReadTimestamp: Bool {return _storage._maxReadTimestamp != nil}
  /// Clears the value of `maxReadTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearMaxReadTimestamp() {_uniqueStorage()._maxReadTimestamp = nil}

  var maxAckTimestamp: Int64 {
    get {return _storage._maxAckTimestamp ?? 0}
    set {_uniqueStorage()._maxAckTimestamp = newValue}
  }
  /// Returns true if `maxAckTimestamp` has been explicitly set.
  var hasMaxAckTimestamp: Bool {return _storage._maxAckTimestamp != nil}
  /// Clears the value of `maxAckTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearMaxAckTimestamp() {_uniqueStorage()._maxAckTimestamp = nil}

  var queryAllMembers: Bool {
    get {return _storage._queryAllMembers ?? false}
    set {_uniqueStorage()._queryAllMembers = newValue}
  }
  /// Returns true if `queryAllMembers` has been explicitly set.
  var hasQueryAllMembers: Bool {return _storage._queryAllMembers != nil}
  /// Clears the value of `queryAllMembers`. Subsequent reads from it will return its default value.
  mutating func clearQueryAllMembers() {_uniqueStorage()._queryAllMembers = nil}

  var maxReadTuples: [IMMaxReadTuple] {
    get {return _storage._maxReadTuples}
    set {_uniqueStorage()._maxReadTuples = newValue}
  }

  var cids: [String] {
    get {return _storage._cids}
    set {_uniqueStorage()._cids = newValue}
  }

  var info: IMConvMemberInfo {
    get {return _storage._info ?? IMConvMemberInfo()}
    set {_uniqueStorage()._info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return _storage._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {_uniqueStorage()._info = nil}

  var tempConv: Bool {
    get {return _storage._tempConv ?? false}
    set {_uniqueStorage()._tempConv = newValue}
  }
  /// Returns true if `tempConv` has been explicitly set.
  var hasTempConv: Bool {return _storage._tempConv != nil}
  /// Clears the value of `tempConv`. Subsequent reads from it will return its default value.
  mutating func clearTempConv() {_uniqueStorage()._tempConv = nil}

  var tempConvTtl: Int32 {
    get {return _storage._tempConvTtl ?? 0}
    set {_uniqueStorage()._tempConvTtl = newValue}
  }
  /// Returns true if `tempConvTtl` has been explicitly set.
  var hasTempConvTtl: Bool {return _storage._tempConvTtl != nil}
  /// Clears the value of `tempConvTtl`. Subsequent reads from it will return its default value.
  mutating func clearTempConvTtl() {_uniqueStorage()._tempConvTtl = nil}

  var tempConvIds: [String] {
    get {return _storage._tempConvIds}
    set {_uniqueStorage()._tempConvIds = newValue}
  }

  var allowedPids: [String] {
    get {return _storage._allowedPids}
    set {_uniqueStorage()._allowedPids = newValue}
  }

  var failedPids: [IMErrorCommand] {
    get {return _storage._failedPids}
    set {_uniqueStorage()._failedPids = newValue}
  }

  /// used in shutup query
  var next: String {
    get {return _storage._next ?? String()}
    set {_uniqueStorage()._next = newValue}
  }
  /// Returns true if `next` has been explicitly set.
  var hasNext: Bool {return _storage._next != nil}
  /// Clears the value of `next`. Subsequent reads from it will return its default value.
  mutating func clearNext() {_uniqueStorage()._next = nil}

  var results: IMJsonObjectMessage {
    get {return _storage._results ?? IMJsonObjectMessage()}
    set {_uniqueStorage()._results = newValue}
  }
  /// Returns true if `results` has been explicitly set.
  var hasResults: Bool {return _storage._results != nil}
  /// Clears the value of `results`. Subsequent reads from it will return its default value.
  mutating func clearResults() {_uniqueStorage()._results = nil}

  var `where`: IMJsonObjectMessage {
    get {return _storage._where ?? IMJsonObjectMessage()}
    set {_uniqueStorage()._where = newValue}
  }
  /// Returns true if ``where`` has been explicitly set.
  var hasWhere: Bool {return _storage._where != nil}
  /// Clears the value of ``where``. Subsequent reads from it will return its default value.
  mutating func clearWhere() {_uniqueStorage()._where = nil}

  var attr: IMJsonObjectMessage {
    get {return _storage._attr ?? IMJsonObjectMessage()}
    set {_uniqueStorage()._attr = newValue}
  }
  /// Returns true if `attr` has been explicitly set.
  var hasAttr: Bool {return _storage._attr != nil}
  /// Clears the value of `attr`. Subsequent reads from it will return its default value.
  mutating func clearAttr() {_uniqueStorage()._attr = nil}

  var attrModified: IMJsonObjectMessage {
    get {return _storage._attrModified ?? IMJsonObjectMessage()}
    set {_uniqueStorage()._attrModified = newValue}
  }
  /// Returns true if `attrModified` has been explicitly set.
  var hasAttrModified: Bool {return _storage._attrModified != nil}
  /// Clears the value of `attrModified`. Subsequent reads from it will return its default value.
  mutating func clearAttrModified() {_uniqueStorage()._attrModified = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct IMRoomCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var roomID: String {
    get {return _roomID ?? String()}
    set {_roomID = newValue}
  }
  /// Returns true if `roomID` has been explicitly set.
  var hasRoomID: Bool {return self._roomID != nil}
  /// Clears the value of `roomID`. Subsequent reads from it will return its default value.
  mutating func clearRoomID() {self._roomID = nil}

  var s: String {
    get {return _s ?? String()}
    set {_s = newValue}
  }
  /// Returns true if `s` has been explicitly set.
  var hasS: Bool {return self._s != nil}
  /// Clears the value of `s`. Subsequent reads from it will return its default value.
  mutating func clearS() {self._s = nil}

  var t: Int64 {
    get {return _t ?? 0}
    set {_t = newValue}
  }
  /// Returns true if `t` has been explicitly set.
  var hasT: Bool {return self._t != nil}
  /// Clears the value of `t`. Subsequent reads from it will return its default value.
  mutating func clearT() {self._t = nil}

  var n: String {
    get {return _n ?? String()}
    set {_n = newValue}
  }
  /// Returns true if `n` has been explicitly set.
  var hasN: Bool {return self._n != nil}
  /// Clears the value of `n`. Subsequent reads from it will return its default value.
  mutating func clearN() {self._n = nil}

  var transient: Bool {
    get {return _transient ?? false}
    set {_transient = newValue}
  }
  /// Returns true if `transient` has been explicitly set.
  var hasTransient: Bool {return self._transient != nil}
  /// Clears the value of `transient`. Subsequent reads from it will return its default value.
  mutating func clearTransient() {self._transient = nil}

  var roomPeerIds: [String] = []

  var byPeerID: String {
    get {return _byPeerID ?? String()}
    set {_byPeerID = newValue}
  }
  /// Returns true if `byPeerID` has been explicitly set.
  var hasByPeerID: Bool {return self._byPeerID != nil}
  /// Clears the value of `byPeerID`. Subsequent reads from it will return its default value.
  mutating func clearByPeerID() {self._byPeerID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _roomID: String? = nil
  fileprivate var _s: String? = nil
  fileprivate var _t: Int64? = nil
  fileprivate var _n: String? = nil
  fileprivate var _transient: Bool? = nil
  fileprivate var _byPeerID: String? = nil
}

struct IMLogsCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cid: String {
    get {return _cid ?? String()}
    set {_cid = newValue}
  }
  /// Returns true if `cid` has been explicitly set.
  var hasCid: Bool {return self._cid != nil}
  /// Clears the value of `cid`. Subsequent reads from it will return its default value.
  mutating func clearCid() {self._cid = nil}

  var l: Int32 {
    get {return _l ?? 0}
    set {_l = newValue}
  }
  /// Returns true if `l` has been explicitly set.
  var hasL: Bool {return self._l != nil}
  /// Clears the value of `l`. Subsequent reads from it will return its default value.
  mutating func clearL() {self._l = nil}

  var limit: Int32 {
    get {return _limit ?? 0}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  mutating func clearLimit() {self._limit = nil}

  var t: Int64 {
    get {return _t ?? 0}
    set {_t = newValue}
  }
  /// Returns true if `t` has been explicitly set.
  var hasT: Bool {return self._t != nil}
  /// Clears the value of `t`. Subsequent reads from it will return its default value.
  mutating func clearT() {self._t = nil}

  var tt: Int64 {
    get {return _tt ?? 0}
    set {_tt = newValue}
  }
  /// Returns true if `tt` has been explicitly set.
  var hasTt: Bool {return self._tt != nil}
  /// Clears the value of `tt`. Subsequent reads from it will return its default value.
  mutating func clearTt() {self._tt = nil}

  var tmid: String {
    get {return _tmid ?? String()}
    set {_tmid = newValue}
  }
  /// Returns true if `tmid` has been explicitly set.
  var hasTmid: Bool {return self._tmid != nil}
  /// Clears the value of `tmid`. Subsequent reads from it will return its default value.
  mutating func clearTmid() {self._tmid = nil}

  var mid: String {
    get {return _mid ?? String()}
    set {_mid = newValue}
  }
  /// Returns true if `mid` has been explicitly set.
  var hasMid: Bool {return self._mid != nil}
  /// Clears the value of `mid`. Subsequent reads from it will return its default value.
  mutating func clearMid() {self._mid = nil}

  var checksum: String {
    get {return _checksum ?? String()}
    set {_checksum = newValue}
  }
  /// Returns true if `checksum` has been explicitly set.
  var hasChecksum: Bool {return self._checksum != nil}
  /// Clears the value of `checksum`. Subsequent reads from it will return its default value.
  mutating func clearChecksum() {self._checksum = nil}

  var stored: Bool {
    get {return _stored ?? false}
    set {_stored = newValue}
  }
  /// Returns true if `stored` has been explicitly set.
  var hasStored: Bool {return self._stored != nil}
  /// Clears the value of `stored`. Subsequent reads from it will return its default value.
  mutating func clearStored() {self._stored = nil}

  var direction: IMLogsCommand.QueryDirection {
    get {return _direction ?? .old}
    set {_direction = newValue}
  }
  /// Returns true if `direction` has been explicitly set.
  var hasDirection: Bool {return self._direction != nil}
  /// Clears the value of `direction`. Subsequent reads from it will return its default value.
  mutating func clearDirection() {self._direction = nil}

  var tIncluded: Bool {
    get {return _tIncluded ?? false}
    set {_tIncluded = newValue}
  }
  /// Returns true if `tIncluded` has been explicitly set.
  var hasTIncluded: Bool {return self._tIncluded != nil}
  /// Clears the value of `tIncluded`. Subsequent reads from it will return its default value.
  mutating func clearTIncluded() {self._tIncluded = nil}

  var ttIncluded: Bool {
    get {return _ttIncluded ?? false}
    set {_ttIncluded = newValue}
  }
  /// Returns true if `ttIncluded` has been explicitly set.
  var hasTtIncluded: Bool {return self._ttIncluded != nil}
  /// Clears the value of `ttIncluded`. Subsequent reads from it will return its default value.
  mutating func clearTtIncluded() {self._ttIncluded = nil}

  var lctype: Int32 {
    get {return _lctype ?? 0}
    set {_lctype = newValue}
  }
  /// Returns true if `lctype` has been explicitly set.
  var hasLctype: Bool {return self._lctype != nil}
  /// Clears the value of `lctype`. Subsequent reads from it will return its default value.
  mutating func clearLctype() {self._lctype = nil}

  var logs: [IMLogItem] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum QueryDirection: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case old // = 1
    case new // = 2

    init() {
      self = .old
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .old
      case 2: self = .new
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .old: return 1
      case .new: return 2
      }
    }

  }

  init() {}

  fileprivate var _cid: String? = nil
  fileprivate var _l: Int32? = nil
  fileprivate var _limit: Int32? = nil
  fileprivate var _t: Int64? = nil
  fileprivate var _tt: Int64? = nil
  fileprivate var _tmid: String? = nil
  fileprivate var _mid: String? = nil
  fileprivate var _checksum: String? = nil
  fileprivate var _stored: Bool? = nil
  fileprivate var _direction: IMLogsCommand.QueryDirection? = nil
  fileprivate var _tIncluded: Bool? = nil
  fileprivate var _ttIncluded: Bool? = nil
  fileprivate var _lctype: Int32? = nil
}

#if swift(>=4.2)

extension IMLogsCommand.QueryDirection: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct IMRcpCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _id ?? String()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var cid: String {
    get {return _cid ?? String()}
    set {_cid = newValue}
  }
  /// Returns true if `cid` has been explicitly set.
  var hasCid: Bool {return self._cid != nil}
  /// Clears the value of `cid`. Subsequent reads from it will return its default value.
  mutating func clearCid() {self._cid = nil}

  var t: Int64 {
    get {return _t ?? 0}
    set {_t = newValue}
  }
  /// Returns true if `t` has been explicitly set.
  var hasT: Bool {return self._t != nil}
  /// Clears the value of `t`. Subsequent reads from it will return its default value.
  mutating func clearT() {self._t = nil}

  var read: Bool {
    get {return _read ?? false}
    set {_read = newValue}
  }
  /// Returns true if `read` has been explicitly set.
  var hasRead: Bool {return self._read != nil}
  /// Clears the value of `read`. Subsequent reads from it will return its default value.
  mutating func clearRead() {self._read = nil}

  var from: String {
    get {return _from ?? String()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  mutating func clearFrom() {self._from = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: String? = nil
  fileprivate var _cid: String? = nil
  fileprivate var _t: Int64? = nil
  fileprivate var _read: Bool? = nil
  fileprivate var _from: String? = nil
}

struct IMReadTuple {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cid: String {
    get {return _cid ?? String()}
    set {_cid = newValue}
  }
  /// Returns true if `cid` has been explicitly set.
  var hasCid: Bool {return self._cid != nil}
  /// Clears the value of `cid`. Subsequent reads from it will return its default value.
  mutating func clearCid() {self._cid = nil}

  var timestamp: Int64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var mid: String {
    get {return _mid ?? String()}
    set {_mid = newValue}
  }
  /// Returns true if `mid` has been explicitly set.
  var hasMid: Bool {return self._mid != nil}
  /// Clears the value of `mid`. Subsequent reads from it will return its default value.
  mutating func clearMid() {self._mid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cid: String? = nil
  fileprivate var _timestamp: Int64? = nil
  fileprivate var _mid: String? = nil
}

struct IMMaxReadTuple {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pid: String {
    get {return _pid ?? String()}
    set {_pid = newValue}
  }
  /// Returns true if `pid` has been explicitly set.
  var hasPid: Bool {return self._pid != nil}
  /// Clears the value of `pid`. Subsequent reads from it will return its default value.
  mutating func clearPid() {self._pid = nil}

  var maxAckTimestamp: Int64 {
    get {return _maxAckTimestamp ?? 0}
    set {_maxAckTimestamp = newValue}
  }
  /// Returns true if `maxAckTimestamp` has been explicitly set.
  var hasMaxAckTimestamp: Bool {return self._maxAckTimestamp != nil}
  /// Clears the value of `maxAckTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearMaxAckTimestamp() {self._maxAckTimestamp = nil}

  var maxReadTimestamp: Int64 {
    get {return _maxReadTimestamp ?? 0}
    set {_maxReadTimestamp = newValue}
  }
  /// Returns true if `maxReadTimestamp` has been explicitly set.
  var hasMaxReadTimestamp: Bool {return self._maxReadTimestamp != nil}
  /// Clears the value of `maxReadTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearMaxReadTimestamp() {self._maxReadTimestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pid: String? = nil
  fileprivate var _maxAckTimestamp: Int64? = nil
  fileprivate var _maxReadTimestamp: Int64? = nil
}

struct IMReadCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cid: String {
    get {return _cid ?? String()}
    set {_cid = newValue}
  }
  /// Returns true if `cid` has been explicitly set.
  var hasCid: Bool {return self._cid != nil}
  /// Clears the value of `cid`. Subsequent reads from it will return its default value.
  mutating func clearCid() {self._cid = nil}

  var cids: [String] = []

  var convs: [IMReadTuple] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cid: String? = nil
}

struct IMPresenceCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: IMStatusType {
    get {return _status ?? .on}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var sessionPeerIds: [String] = []

  var cid: String {
    get {return _cid ?? String()}
    set {_cid = newValue}
  }
  /// Returns true if `cid` has been explicitly set.
  var hasCid: Bool {return self._cid != nil}
  /// Clears the value of `cid`. Subsequent reads from it will return its default value.
  mutating func clearCid() {self._cid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _status: IMStatusType? = nil
  fileprivate var _cid: String? = nil
}

struct IMReportCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var initiative: Bool {
    get {return _initiative ?? false}
    set {_initiative = newValue}
  }
  /// Returns true if `initiative` has been explicitly set.
  var hasInitiative: Bool {return self._initiative != nil}
  /// Clears the value of `initiative`. Subsequent reads from it will return its default value.
  mutating func clearInitiative() {self._initiative = nil}

  var type: String {
    get {return _type ?? String()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var data: String {
    get {return _data ?? String()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _initiative: Bool? = nil
  fileprivate var _type: String? = nil
  fileprivate var _data: String? = nil
}

struct IMPatchItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cid: String {
    get {return _cid ?? String()}
    set {_cid = newValue}
  }
  /// Returns true if `cid` has been explicitly set.
  var hasCid: Bool {return self._cid != nil}
  /// Clears the value of `cid`. Subsequent reads from it will return its default value.
  mutating func clearCid() {self._cid = nil}

  var mid: String {
    get {return _mid ?? String()}
    set {_mid = newValue}
  }
  /// Returns true if `mid` has been explicitly set.
  var hasMid: Bool {return self._mid != nil}
  /// Clears the value of `mid`. Subsequent reads from it will return its default value.
  mutating func clearMid() {self._mid = nil}

  var timestamp: Int64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var recall: Bool {
    get {return _recall ?? false}
    set {_recall = newValue}
  }
  /// Returns true if `recall` has been explicitly set.
  var hasRecall: Bool {return self._recall != nil}
  /// Clears the value of `recall`. Subsequent reads from it will return its default value.
  mutating func clearRecall() {self._recall = nil}

  var data: String {
    get {return _data ?? String()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  var patchTimestamp: Int64 {
    get {return _patchTimestamp ?? 0}
    set {_patchTimestamp = newValue}
  }
  /// Returns true if `patchTimestamp` has been explicitly set.
  var hasPatchTimestamp: Bool {return self._patchTimestamp != nil}
  /// Clears the value of `patchTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearPatchTimestamp() {self._patchTimestamp = nil}

  var from: String {
    get {return _from ?? String()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  mutating func clearFrom() {self._from = nil}

  var binaryMsg: Data {
    get {return _binaryMsg ?? SwiftProtobuf.Internal.emptyData}
    set {_binaryMsg = newValue}
  }
  /// Returns true if `binaryMsg` has been explicitly set.
  var hasBinaryMsg: Bool {return self._binaryMsg != nil}
  /// Clears the value of `binaryMsg`. Subsequent reads from it will return its default value.
  mutating func clearBinaryMsg() {self._binaryMsg = nil}

  var mentionAll: Bool {
    get {return _mentionAll ?? false}
    set {_mentionAll = newValue}
  }
  /// Returns true if `mentionAll` has been explicitly set.
  var hasMentionAll: Bool {return self._mentionAll != nil}
  /// Clears the value of `mentionAll`. Subsequent reads from it will return its default value.
  mutating func clearMentionAll() {self._mentionAll = nil}

  var mentionPids: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _cid: String? = nil
  fileprivate var _mid: String? = nil
  fileprivate var _timestamp: Int64? = nil
  fileprivate var _recall: Bool? = nil
  fileprivate var _data: String? = nil
  fileprivate var _patchTimestamp: Int64? = nil
  fileprivate var _from: String? = nil
  fileprivate var _binaryMsg: Data? = nil
  fileprivate var _mentionAll: Bool? = nil
}

struct IMPatchCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var patches: [IMPatchItem] = []

  var lastPatchTime: Int64 {
    get {return _lastPatchTime ?? 0}
    set {_lastPatchTime = newValue}
  }
  /// Returns true if `lastPatchTime` has been explicitly set.
  var hasLastPatchTime: Bool {return self._lastPatchTime != nil}
  /// Clears the value of `lastPatchTime`. Subsequent reads from it will return its default value.
  mutating func clearLastPatchTime() {self._lastPatchTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastPatchTime: Int64? = nil
}

struct IMPubsubCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cid: String {
    get {return _storage._cid ?? String()}
    set {_uniqueStorage()._cid = newValue}
  }
  /// Returns true if `cid` has been explicitly set.
  var hasCid: Bool {return _storage._cid != nil}
  /// Clears the value of `cid`. Subsequent reads from it will return its default value.
  mutating func clearCid() {_uniqueStorage()._cid = nil}

  var cids: [String] {
    get {return _storage._cids}
    set {_uniqueStorage()._cids = newValue}
  }

  var topic: String {
    get {return _storage._topic ?? String()}
    set {_uniqueStorage()._topic = newValue}
  }
  /// Returns true if `topic` has been explicitly set.
  var hasTopic: Bool {return _storage._topic != nil}
  /// Clears the value of `topic`. Subsequent reads from it will return its default value.
  mutating func clearTopic() {_uniqueStorage()._topic = nil}

  var subtopic: String {
    get {return _storage._subtopic ?? String()}
    set {_uniqueStorage()._subtopic = newValue}
  }
  /// Returns true if `subtopic` has been explicitly set.
  var hasSubtopic: Bool {return _storage._subtopic != nil}
  /// Clears the value of `subtopic`. Subsequent reads from it will return its default value.
  mutating func clearSubtopic() {_uniqueStorage()._subtopic = nil}

  var topics: [String] {
    get {return _storage._topics}
    set {_uniqueStorage()._topics = newValue}
  }

  var subtopics: [String] {
    get {return _storage._subtopics}
    set {_uniqueStorage()._subtopics = newValue}
  }

  var results: IMJsonObjectMessage {
    get {return _storage._results ?? IMJsonObjectMessage()}
    set {_uniqueStorage()._results = newValue}
  }
  /// Returns true if `results` has been explicitly set.
  var hasResults: Bool {return _storage._results != nil}
  /// Clears the value of `results`. Subsequent reads from it will return its default value.
  mutating func clearResults() {_uniqueStorage()._results = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct IMBlacklistCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var srcCid: String {
    get {return _srcCid ?? String()}
    set {_srcCid = newValue}
  }
  /// Returns true if `srcCid` has been explicitly set.
  var hasSrcCid: Bool {return self._srcCid != nil}
  /// Clears the value of `srcCid`. Subsequent reads from it will return its default value.
  mutating func clearSrcCid() {self._srcCid = nil}

  var toPids: [String] = []

  var srcPid: String {
    get {return _srcPid ?? String()}
    set {_srcPid = newValue}
  }
  /// Returns true if `srcPid` has been explicitly set.
  var hasSrcPid: Bool {return self._srcPid != nil}
  /// Clears the value of `srcPid`. Subsequent reads from it will return its default value.
  mutating func clearSrcPid() {self._srcPid = nil}

  var toCids: [String] = []

  var limit: Int32 {
    get {return _limit ?? 0}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  mutating func clearLimit() {self._limit = nil}

  var next: String {
    get {return _next ?? String()}
    set {_next = newValue}
  }
  /// Returns true if `next` has been explicitly set.
  var hasNext: Bool {return self._next != nil}
  /// Clears the value of `next`. Subsequent reads from it will return its default value.
  mutating func clearNext() {self._next = nil}

  var blockedPids: [String] = []

  var blockedCids: [String] = []

  var allowedPids: [String] = []

  var failedPids: [IMErrorCommand] = []

  var t: Int64 {
    get {return _t ?? 0}
    set {_t = newValue}
  }
  /// Returns true if `t` has been explicitly set.
  var hasT: Bool {return self._t != nil}
  /// Clears the value of `t`. Subsequent reads from it will return its default value.
  mutating func clearT() {self._t = nil}

  var n: String {
    get {return _n ?? String()}
    set {_n = newValue}
  }
  /// Returns true if `n` has been explicitly set.
  var hasN: Bool {return self._n != nil}
  /// Clears the value of `n`. Subsequent reads from it will return its default value.
  mutating func clearN() {self._n = nil}

  var s: String {
    get {return _s ?? String()}
    set {_s = newValue}
  }
  /// Returns true if `s` has been explicitly set.
  var hasS: Bool {return self._s != nil}
  /// Clears the value of `s`. Subsequent reads from it will return its default value.
  mutating func clearS() {self._s = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _srcCid: String? = nil
  fileprivate var _srcPid: String? = nil
  fileprivate var _limit: Int32? = nil
  fileprivate var _next: String? = nil
  fileprivate var _t: Int64? = nil
  fileprivate var _n: String? = nil
  fileprivate var _s: String? = nil
}

struct IMGenericCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cmd: IMCommandType {
    get {return _storage._cmd ?? .session}
    set {_uniqueStorage()._cmd = newValue}
  }
  /// Returns true if `cmd` has been explicitly set.
  var hasCmd: Bool {return _storage._cmd != nil}
  /// Clears the value of `cmd`. Subsequent reads from it will return its default value.
  mutating func clearCmd() {_uniqueStorage()._cmd = nil}

  var op: IMOpType {
    get {return _storage._op ?? .open}
    set {_uniqueStorage()._op = newValue}
  }
  /// Returns true if `op` has been explicitly set.
  var hasOp: Bool {return _storage._op != nil}
  /// Clears the value of `op`. Subsequent reads from it will return its default value.
  mutating func clearOp() {_uniqueStorage()._op = nil}

  var appID: String {
    get {return _storage._appID ?? String()}
    set {_uniqueStorage()._appID = newValue}
  }
  /// Returns true if `appID` has been explicitly set.
  var hasAppID: Bool {return _storage._appID != nil}
  /// Clears the value of `appID`. Subsequent reads from it will return its default value.
  mutating func clearAppID() {_uniqueStorage()._appID = nil}

  var peerID: String {
    get {return _storage._peerID ?? String()}
    set {_uniqueStorage()._peerID = newValue}
  }
  /// Returns true if `peerID` has been explicitly set.
  var hasPeerID: Bool {return _storage._peerID != nil}
  /// Clears the value of `peerID`. Subsequent reads from it will return its default value.
  mutating func clearPeerID() {_uniqueStorage()._peerID = nil}

  var i: Int32 {
    get {return _storage._i ?? 0}
    set {_uniqueStorage()._i = newValue}
  }
  /// Returns true if `i` has been explicitly set.
  var hasI: Bool {return _storage._i != nil}
  /// Clears the value of `i`. Subsequent reads from it will return its default value.
  mutating func clearI() {_uniqueStorage()._i = nil}

  var installationID: String {
    get {return _storage._installationID ?? String()}
    set {_uniqueStorage()._installationID = newValue}
  }
  /// Returns true if `installationID` has been explicitly set.
  var hasInstallationID: Bool {return _storage._installationID != nil}
  /// Clears the value of `installationID`. Subsequent reads from it will return its default value.
  mutating func clearInstallationID() {_uniqueStorage()._installationID = nil}

  var priority: Int32 {
    get {return _storage._priority ?? 0}
    set {_uniqueStorage()._priority = newValue}
  }
  /// Returns true if `priority` has been explicitly set.
  var hasPriority: Bool {return _storage._priority != nil}
  /// Clears the value of `priority`. Subsequent reads from it will return its default value.
  mutating func clearPriority() {_uniqueStorage()._priority = nil}

  var service: Int32 {
    get {return _storage._service ?? 0}
    set {_uniqueStorage()._service = newValue}
  }
  /// Returns true if `service` has been explicitly set.
  var hasService: Bool {return _storage._service != nil}
  /// Clears the value of `service`. Subsequent reads from it will return its default value.
  mutating func clearService() {_uniqueStorage()._service = nil}

  var serverTs: Int64 {
    get {return _storage._serverTs ?? 0}
    set {_uniqueStorage()._serverTs = newValue}
  }
  /// Returns true if `serverTs` has been explicitly set.
  var hasServerTs: Bool {return _storage._serverTs != nil}
  /// Clears the value of `serverTs`. Subsequent reads from it will return its default value.
  mutating func clearServerTs() {_uniqueStorage()._serverTs = nil}

  var dataMessage: IMDataCommand {
    get {return _storage._dataMessage ?? IMDataCommand()}
    set {_uniqueStorage()._dataMessage = newValue}
  }
  /// Returns true if `dataMessage` has been explicitly set.
  var hasDataMessage: Bool {return _storage._dataMessage != nil}
  /// Clears the value of `dataMessage`. Subsequent reads from it will return its default value.
  mutating func clearDataMessage() {_uniqueStorage()._dataMessage = nil}

  var sessionMessage: IMSessionCommand {
    get {return _storage._sessionMessage ?? IMSessionCommand()}
    set {_uniqueStorage()._sessionMessage = newValue}
  }
  /// Returns true if `sessionMessage` has been explicitly set.
  var hasSessionMessage: Bool {return _storage._sessionMessage != nil}
  /// Clears the value of `sessionMessage`. Subsequent reads from it will return its default value.
  mutating func clearSessionMessage() {_uniqueStorage()._sessionMessage = nil}

  var errorMessage: IMErrorCommand {
    get {return _storage._errorMessage ?? IMErrorCommand()}
    set {_uniqueStorage()._errorMessage = newValue}
  }
  /// Returns true if `errorMessage` has been explicitly set.
  var hasErrorMessage: Bool {return _storage._errorMessage != nil}
  /// Clears the value of `errorMessage`. Subsequent reads from it will return its default value.
  mutating func clearErrorMessage() {_uniqueStorage()._errorMessage = nil}

  var directMessage: IMDirectCommand {
    get {return _storage._directMessage ?? IMDirectCommand()}
    set {_uniqueStorage()._directMessage = newValue}
  }
  /// Returns true if `directMessage` has been explicitly set.
  var hasDirectMessage: Bool {return _storage._directMessage != nil}
  /// Clears the value of `directMessage`. Subsequent reads from it will return its default value.
  mutating func clearDirectMessage() {_uniqueStorage()._directMessage = nil}

  var ackMessage: IMAckCommand {
    get {return _storage._ackMessage ?? IMAckCommand()}
    set {_uniqueStorage()._ackMessage = newValue}
  }
  /// Returns true if `ackMessage` has been explicitly set.
  var hasAckMessage: Bool {return _storage._ackMessage != nil}
  /// Clears the value of `ackMessage`. Subsequent reads from it will return its default value.
  mutating func clearAckMessage() {_uniqueStorage()._ackMessage = nil}

  var unreadMessage: IMUnreadCommand {
    get {return _storage._unreadMessage ?? IMUnreadCommand()}
    set {_uniqueStorage()._unreadMessage = newValue}
  }
  /// Returns true if `unreadMessage` has been explicitly set.
  var hasUnreadMessage: Bool {return _storage._unreadMessage != nil}
  /// Clears the value of `unreadMessage`. Subsequent reads from it will return its default value.
  mutating func clearUnreadMessage() {_uniqueStorage()._unreadMessage = nil}

  var readMessage: IMReadCommand {
    get {return _storage._readMessage ?? IMReadCommand()}
    set {_uniqueStorage()._readMessage = newValue}
  }
  /// Returns true if `readMessage` has been explicitly set.
  var hasReadMessage: Bool {return _storage._readMessage != nil}
  /// Clears the value of `readMessage`. Subsequent reads from it will return its default value.
  mutating func clearReadMessage() {_uniqueStorage()._readMessage = nil}

  var rcpMessage: IMRcpCommand {
    get {return _storage._rcpMessage ?? IMRcpCommand()}
    set {_uniqueStorage()._rcpMessage = newValue}
  }
  /// Returns true if `rcpMessage` has been explicitly set.
  var hasRcpMessage: Bool {return _storage._rcpMessage != nil}
  /// Clears the value of `rcpMessage`. Subsequent reads from it will return its default value.
  mutating func clearRcpMessage() {_uniqueStorage()._rcpMessage = nil}

  var logsMessage: IMLogsCommand {
    get {return _storage._logsMessage ?? IMLogsCommand()}
    set {_uniqueStorage()._logsMessage = newValue}
  }
  /// Returns true if `logsMessage` has been explicitly set.
  var hasLogsMessage: Bool {return _storage._logsMessage != nil}
  /// Clears the value of `logsMessage`. Subsequent reads from it will return its default value.
  mutating func clearLogsMessage() {_uniqueStorage()._logsMessage = nil}

  var convMessage: IMConvCommand {
    get {return _storage._convMessage ?? IMConvCommand()}
    set {_uniqueStorage()._convMessage = newValue}
  }
  /// Returns true if `convMessage` has been explicitly set.
  var hasConvMessage: Bool {return _storage._convMessage != nil}
  /// Clears the value of `convMessage`. Subsequent reads from it will return its default value.
  mutating func clearConvMessage() {_uniqueStorage()._convMessage = nil}

  var roomMessage: IMRoomCommand {
    get {return _storage._roomMessage ?? IMRoomCommand()}
    set {_uniqueStorage()._roomMessage = newValue}
  }
  /// Returns true if `roomMessage` has been explicitly set.
  var hasRoomMessage: Bool {return _storage._roomMessage != nil}
  /// Clears the value of `roomMessage`. Subsequent reads from it will return its default value.
  mutating func clearRoomMessage() {_uniqueStorage()._roomMessage = nil}

  var presenceMessage: IMPresenceCommand {
    get {return _storage._presenceMessage ?? IMPresenceCommand()}
    set {_uniqueStorage()._presenceMessage = newValue}
  }
  /// Returns true if `presenceMessage` has been explicitly set.
  var hasPresenceMessage: Bool {return _storage._presenceMessage != nil}
  /// Clears the value of `presenceMessage`. Subsequent reads from it will return its default value.
  mutating func clearPresenceMessage() {_uniqueStorage()._presenceMessage = nil}

  var reportMessage: IMReportCommand {
    get {return _storage._reportMessage ?? IMReportCommand()}
    set {_uniqueStorage()._reportMessage = newValue}
  }
  /// Returns true if `reportMessage` has been explicitly set.
  var hasReportMessage: Bool {return _storage._reportMessage != nil}
  /// Clears the value of `reportMessage`. Subsequent reads from it will return its default value.
  mutating func clearReportMessage() {_uniqueStorage()._reportMessage = nil}

  var patchMessage: IMPatchCommand {
    get {return _storage._patchMessage ?? IMPatchCommand()}
    set {_uniqueStorage()._patchMessage = newValue}
  }
  /// Returns true if `patchMessage` has been explicitly set.
  var hasPatchMessage: Bool {return _storage._patchMessage != nil}
  /// Clears the value of `patchMessage`. Subsequent reads from it will return its default value.
  mutating func clearPatchMessage() {_uniqueStorage()._patchMessage = nil}

  var pubsubMessage: IMPubsubCommand {
    get {return _storage._pubsubMessage ?? IMPubsubCommand()}
    set {_uniqueStorage()._pubsubMessage = newValue}
  }
  /// Returns true if `pubsubMessage` has been explicitly set.
  var hasPubsubMessage: Bool {return _storage._pubsubMessage != nil}
  /// Clears the value of `pubsubMessage`. Subsequent reads from it will return its default value.
  mutating func clearPubsubMessage() {_uniqueStorage()._pubsubMessage = nil}

  var blacklistMessage: IMBlacklistCommand {
    get {return _storage._blacklistMessage ?? IMBlacklistCommand()}
    set {_uniqueStorage()._blacklistMessage = newValue}
  }
  /// Returns true if `blacklistMessage` has been explicitly set.
  var hasBlacklistMessage: Bool {return _storage._blacklistMessage != nil}
  /// Clears the value of `blacklistMessage`. Subsequent reads from it will return its default value.
  mutating func clearBlacklistMessage() {_uniqueStorage()._blacklistMessage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "push_server.messages2"

extension IMCommandType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "session"),
    1: .same(proto: "conv"),
    2: .same(proto: "direct"),
    3: .same(proto: "ack"),
    4: .same(proto: "rcp"),
    5: .same(proto: "unread"),
    6: .same(proto: "logs"),
    7: .same(proto: "error"),
    8: .same(proto: "login"),
    9: .same(proto: "data"),
    10: .same(proto: "room"),
    11: .same(proto: "read"),
    12: .same(proto: "presence"),
    13: .same(proto: "report"),
    14: .same(proto: "echo"),
    15: .same(proto: "loggedin"),
    16: .same(proto: "logout"),
    17: .same(proto: "loggedout"),
    18: .same(proto: "patch"),
    19: .same(proto: "pubsub"),
    20: .same(proto: "blacklist"),
  ]
}

extension IMOpType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "open"),
    2: .same(proto: "add"),
    3: .same(proto: "remove"),
    4: .same(proto: "close"),
    5: .same(proto: "opened"),
    6: .same(proto: "closed"),
    7: .same(proto: "query"),
    8: .same(proto: "query_result"),
    9: .same(proto: "conflict"),
    10: .same(proto: "added"),
    11: .same(proto: "removed"),
    12: .same(proto: "refresh"),
    13: .same(proto: "refreshed"),
    30: .same(proto: "start"),
    31: .same(proto: "started"),
    32: .same(proto: "joined"),
    33: .same(proto: "members_joined"),
    39: .same(proto: "left"),
    40: .same(proto: "members_left"),
    42: .same(proto: "results"),
    43: .same(proto: "count"),
    44: .same(proto: "result"),
    45: .same(proto: "update"),
    46: .same(proto: "updated"),
    47: .same(proto: "mute"),
    48: .same(proto: "unmute"),
    49: .same(proto: "status"),
    50: .same(proto: "members"),
    51: .same(proto: "max_read"),
    52: .same(proto: "is_member"),
    53: .same(proto: "member_info_update"),
    54: .same(proto: "member_info_updated"),
    55: .same(proto: "member_info_changed"),
    80: .same(proto: "join"),
    81: .same(proto: "invite"),
    82: .same(proto: "leave"),
    83: .same(proto: "kick"),
    84: .same(proto: "reject"),
    85: .same(proto: "invited"),
    86: .same(proto: "kicked"),
    100: .same(proto: "upload"),
    101: .same(proto: "uploaded"),
    120: .same(proto: "subscribe"),
    121: .same(proto: "subscribed"),
    122: .same(proto: "unsubscribe"),
    123: .same(proto: "unsubscribed"),
    124: .same(proto: "is_subscribed"),
    150: .same(proto: "modify"),
    151: .same(proto: "modified"),
    170: .same(proto: "block"),
    171: .same(proto: "unblock"),
    172: .same(proto: "blocked"),
    173: .same(proto: "unblocked"),
    174: .same(proto: "members_blocked"),
    175: .same(proto: "members_unblocked"),
    180: .same(proto: "add_shutup"),
    181: .same(proto: "remove_shutup"),
    182: .same(proto: "query_shutup"),
    183: .same(proto: "shutup_added"),
    184: .same(proto: "shutup_removed"),
    185: .same(proto: "shutup_result"),
    186: .same(proto: "shutuped"),
    187: .same(proto: "unshutuped"),
    188: .same(proto: "members_shutuped"),
    189: .same(proto: "members_unshutuped"),
  ]
}

extension IMStatusType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "on"),
    2: .same(proto: "off"),
  ]
}

extension IMJsonObjectMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JsonObjectMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public var isInitialized: Bool {
    if self._data == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._data)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._data {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IMJsonObjectMessage, rhs: IMJsonObjectMessage) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMUnreadTuple: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnreadTuple"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cid"),
    2: .same(proto: "unread"),
    3: .same(proto: "mid"),
    4: .same(proto: "timestamp"),
    5: .same(proto: "from"),
    6: .same(proto: "data"),
    7: .same(proto: "patchTimestamp"),
    8: .same(proto: "mentioned"),
    9: .same(proto: "binaryMsg"),
    10: .same(proto: "convType"),
  ]

  public var isInitialized: Bool {
    if self._cid == nil {return false}
    if self._unread == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._cid)
      case 2: try decoder.decodeSingularInt32Field(value: &self._unread)
      case 3: try decoder.decodeSingularStringField(value: &self._mid)
      case 4: try decoder.decodeSingularInt64Field(value: &self._timestamp)
      case 5: try decoder.decodeSingularStringField(value: &self._from)
      case 6: try decoder.decodeSingularStringField(value: &self._data)
      case 7: try decoder.decodeSingularInt64Field(value: &self._patchTimestamp)
      case 8: try decoder.decodeSingularBoolField(value: &self._mentioned)
      case 9: try decoder.decodeSingularBytesField(value: &self._binaryMsg)
      case 10: try decoder.decodeSingularInt32Field(value: &self._convType)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._cid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._unread {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._timestamp {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    }
    if let v = self._from {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._data {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if let v = self._patchTimestamp {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 7)
    }
    if let v = self._mentioned {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    }
    if let v = self._binaryMsg {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
    }
    if let v = self._convType {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IMUnreadTuple, rhs: IMUnreadTuple) -> Bool {
    if lhs._cid != rhs._cid {return false}
    if lhs._unread != rhs._unread {return false}
    if lhs._mid != rhs._mid {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._from != rhs._from {return false}
    if lhs._data != rhs._data {return false}
    if lhs._patchTimestamp != rhs._patchTimestamp {return false}
    if lhs._mentioned != rhs._mentioned {return false}
    if lhs._binaryMsg != rhs._binaryMsg {return false}
    if lhs._convType != rhs._convType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMLogItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LogItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "data"),
    3: .same(proto: "timestamp"),
    4: .same(proto: "msgId"),
    5: .same(proto: "ackAt"),
    6: .same(proto: "readAt"),
    7: .same(proto: "patchTimestamp"),
    8: .same(proto: "mentionAll"),
    9: .same(proto: "mentionPids"),
    10: .same(proto: "bin"),
    11: .same(proto: "convType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._from)
      case 2: try decoder.decodeSingularStringField(value: &self._data)
      case 3: try decoder.decodeSingularInt64Field(value: &self._timestamp)
      case 4: try decoder.decodeSingularStringField(value: &self._msgID)
      case 5: try decoder.decodeSingularInt64Field(value: &self._ackAt)
      case 6: try decoder.decodeSingularInt64Field(value: &self._readAt)
      case 7: try decoder.decodeSingularInt64Field(value: &self._patchTimestamp)
      case 8: try decoder.decodeSingularBoolField(value: &self._mentionAll)
      case 9: try decoder.decodeRepeatedStringField(value: &self.mentionPids)
      case 10: try decoder.decodeSingularBoolField(value: &self._bin)
      case 11: try decoder.decodeSingularInt32Field(value: &self._convType)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._from {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._data {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._timestamp {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }
    if let v = self._msgID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._ackAt {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    }
    if let v = self._readAt {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 6)
    }
    if let v = self._patchTimestamp {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 7)
    }
    if let v = self._mentionAll {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    }
    if !self.mentionPids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.mentionPids, fieldNumber: 9)
    }
    if let v = self._bin {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    }
    if let v = self._convType {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IMLogItem, rhs: IMLogItem) -> Bool {
    if lhs._from != rhs._from {return false}
    if lhs._data != rhs._data {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._msgID != rhs._msgID {return false}
    if lhs._ackAt != rhs._ackAt {return false}
    if lhs._readAt != rhs._readAt {return false}
    if lhs._patchTimestamp != rhs._patchTimestamp {return false}
    if lhs._mentionAll != rhs._mentionAll {return false}
    if lhs.mentionPids != rhs.mentionPids {return false}
    if lhs._bin != rhs._bin {return false}
    if lhs._convType != rhs._convType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMConvMemberInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConvMemberInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pid"),
    2: .same(proto: "role"),
    3: .same(proto: "infoId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._pid)
      case 2: try decoder.decodeSingularStringField(value: &self._role)
      case 3: try decoder.decodeSingularStringField(value: &self._infoID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._pid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._role {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._infoID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IMConvMemberInfo, rhs: IMConvMemberInfo) -> Bool {
    if lhs._pid != rhs._pid {return false}
    if lhs._role != rhs._role {return false}
    if lhs._infoID != rhs._infoID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMDataCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DataCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
    2: .same(proto: "msg"),
    3: .same(proto: "offline"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.msg) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.ids)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.msg)
      case 3: try decoder.decodeSingularBoolField(value: &self._offline)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 1)
    }
    if !self.msg.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.msg, fieldNumber: 2)
    }
    if let v = self._offline {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IMDataCommand, rhs: IMDataCommand) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.msg != rhs.msg {return false}
    if lhs._offline != rhs._offline {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMSessionCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "t"),
    2: .same(proto: "n"),
    3: .same(proto: "s"),
    4: .same(proto: "ua"),
    5: .same(proto: "r"),
    6: .same(proto: "tag"),
    7: .same(proto: "deviceId"),
    8: .same(proto: "sessionPeerIds"),
    9: .same(proto: "onlineSessionPeerIds"),
    10: .same(proto: "st"),
    11: .same(proto: "stTtl"),
    12: .same(proto: "code"),
    13: .same(proto: "reason"),
    14: .same(proto: "deviceToken"),
    15: .same(proto: "sp"),
    16: .same(proto: "detail"),
    17: .same(proto: "lastUnreadNotifTime"),
    18: .same(proto: "lastPatchTime"),
    19: .same(proto: "configBitmap"),
  ]

  fileprivate class _StorageClass {
    var _t: Int64? = nil
    var _n: String? = nil
    var _s: String? = nil
    var _ua: String? = nil
    var _r: Bool? = nil
    var _tag: String? = nil
    var _deviceID: String? = nil
    var _sessionPeerIds: [String] = []
    var _onlineSessionPeerIds: [String] = []
    var _st: String? = nil
    var _stTtl: Int32? = nil
    var _code: Int32? = nil
    var _reason: String? = nil
    var _deviceToken: String? = nil
    var _sp: Bool? = nil
    var _detail: String? = nil
    var _lastUnreadNotifTime: Int64? = nil
    var _lastPatchTime: Int64? = nil
    var _configBitmap: Int64? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _t = source._t
      _n = source._n
      _s = source._s
      _ua = source._ua
      _r = source._r
      _tag = source._tag
      _deviceID = source._deviceID
      _sessionPeerIds = source._sessionPeerIds
      _onlineSessionPeerIds = source._onlineSessionPeerIds
      _st = source._st
      _stTtl = source._stTtl
      _code = source._code
      _reason = source._reason
      _deviceToken = source._deviceToken
      _sp = source._sp
      _detail = source._detail
      _lastUnreadNotifTime = source._lastUnreadNotifTime
      _lastPatchTime = source._lastPatchTime
      _configBitmap = source._configBitmap
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt64Field(value: &_storage._t)
        case 2: try decoder.decodeSingularStringField(value: &_storage._n)
        case 3: try decoder.decodeSingularStringField(value: &_storage._s)
        case 4: try decoder.decodeSingularStringField(value: &_storage._ua)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._r)
        case 6: try decoder.decodeSingularStringField(value: &_storage._tag)
        case 7: try decoder.decodeSingularStringField(value: &_storage._deviceID)
        case 8: try decoder.decodeRepeatedStringField(value: &_storage._sessionPeerIds)
        case 9: try decoder.decodeRepeatedStringField(value: &_storage._onlineSessionPeerIds)
        case 10: try decoder.decodeSingularStringField(value: &_storage._st)
        case 11: try decoder.decodeSingularInt32Field(value: &_storage._stTtl)
        case 12: try decoder.decodeSingularInt32Field(value: &_storage._code)
        case 13: try decoder.decodeSingularStringField(value: &_storage._reason)
        case 14: try decoder.decodeSingularStringField(value: &_storage._deviceToken)
        case 15: try decoder.decodeSingularBoolField(value: &_storage._sp)
        case 16: try decoder.decodeSingularStringField(value: &_storage._detail)
        case 17: try decoder.decodeSingularInt64Field(value: &_storage._lastUnreadNotifTime)
        case 18: try decoder.decodeSingularInt64Field(value: &_storage._lastPatchTime)
        case 19: try decoder.decodeSingularInt64Field(value: &_storage._configBitmap)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._t {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._n {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._s {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._ua {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._r {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      }
      if let v = _storage._tag {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._deviceID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      }
      if !_storage._sessionPeerIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._sessionPeerIds, fieldNumber: 8)
      }
      if !_storage._onlineSessionPeerIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._onlineSessionPeerIds, fieldNumber: 9)
      }
      if let v = _storage._st {
        try visitor.visitSingularStringField(value: v, fieldNumber: 10)
      }
      if let v = _storage._stTtl {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 11)
      }
      if let v = _storage._code {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 12)
      }
      if let v = _storage._reason {
        try visitor.visitSingularStringField(value: v, fieldNumber: 13)
      }
      if let v = _storage._deviceToken {
        try visitor.visitSingularStringField(value: v, fieldNumber: 14)
      }
      if let v = _storage._sp {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 15)
      }
      if let v = _storage._detail {
        try visitor.visitSingularStringField(value: v, fieldNumber: 16)
      }
      if let v = _storage._lastUnreadNotifTime {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 17)
      }
      if let v = _storage._lastPatchTime {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 18)
      }
      if let v = _storage._configBitmap {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IMSessionCommand, rhs: IMSessionCommand) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._t != rhs_storage._t {return false}
        if _storage._n != rhs_storage._n {return false}
        if _storage._s != rhs_storage._s {return false}
        if _storage._ua != rhs_storage._ua {return false}
        if _storage._r != rhs_storage._r {return false}
        if _storage._tag != rhs_storage._tag {return false}
        if _storage._deviceID != rhs_storage._deviceID {return false}
        if _storage._sessionPeerIds != rhs_storage._sessionPeerIds {return false}
        if _storage._onlineSessionPeerIds != rhs_storage._onlineSessionPeerIds {return false}
        if _storage._st != rhs_storage._st {return false}
        if _storage._stTtl != rhs_storage._stTtl {return false}
        if _storage._code != rhs_storage._code {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._deviceToken != rhs_storage._deviceToken {return false}
        if _storage._sp != rhs_storage._sp {return false}
        if _storage._detail != rhs_storage._detail {return false}
        if _storage._lastUnreadNotifTime != rhs_storage._lastUnreadNotifTime {return false}
        if _storage._lastPatchTime != rhs_storage._lastPatchTime {return false}
        if _storage._configBitmap != rhs_storage._configBitmap {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMErrorCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ErrorCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "reason"),
    3: .same(proto: "appCode"),
    4: .same(proto: "detail"),
    5: .same(proto: "pids"),
  ]

  public var isInitialized: Bool {
    if self._code == nil {return false}
    if self._reason == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self._code)
      case 2: try decoder.decodeSingularStringField(value: &self._reason)
      case 3: try decoder.decodeSingularInt32Field(value: &self._appCode)
      case 4: try decoder.decodeSingularStringField(value: &self._detail)
      case 5: try decoder.decodeRepeatedStringField(value: &self.pids)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._code {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._appCode {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._detail {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if !self.pids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pids, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IMErrorCommand, rhs: IMErrorCommand) -> Bool {
    if lhs._code != rhs._code {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs._appCode != rhs._appCode {return false}
    if lhs._detail != rhs._detail {return false}
    if lhs.pids != rhs.pids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMDirectCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DirectCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
    2: .same(proto: "uid"),
    3: .same(proto: "fromPeerId"),
    4: .same(proto: "timestamp"),
    5: .same(proto: "offline"),
    6: .same(proto: "hasMore"),
    7: .same(proto: "toPeerIds"),
    10: .same(proto: "r"),
    11: .same(proto: "cid"),
    12: .same(proto: "id"),
    13: .same(proto: "transient"),
    14: .same(proto: "dt"),
    15: .same(proto: "roomId"),
    16: .same(proto: "pushData"),
    17: .same(proto: "will"),
    18: .same(proto: "patchTimestamp"),
    19: .same(proto: "binaryMsg"),
    20: .same(proto: "mentionPids"),
    21: .same(proto: "mentionAll"),
    22: .same(proto: "convType"),
  ]

  fileprivate class _StorageClass {
    var _msg: String? = nil
    var _uid: String? = nil
    var _fromPeerID: String? = nil
    var _timestamp: Int64? = nil
    var _offline: Bool? = nil
    var _hasMore_p: Bool? = nil
    var _toPeerIds: [String] = []
    var _r: Bool? = nil
    var _cid: String? = nil
    var _id: String? = nil
    var _transient: Bool? = nil
    var _dt: String? = nil
    var _roomID: String? = nil
    var _pushData: String? = nil
    var _will: Bool? = nil
    var _patchTimestamp: Int64? = nil
    var _binaryMsg: Data? = nil
    var _mentionPids: [String] = []
    var _mentionAll: Bool? = nil
    var _convType: Int32? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _msg = source._msg
      _uid = source._uid
      _fromPeerID = source._fromPeerID
      _timestamp = source._timestamp
      _offline = source._offline
      _hasMore_p = source._hasMore_p
      _toPeerIds = source._toPeerIds
      _r = source._r
      _cid = source._cid
      _id = source._id
      _transient = source._transient
      _dt = source._dt
      _roomID = source._roomID
      _pushData = source._pushData
      _will = source._will
      _patchTimestamp = source._patchTimestamp
      _binaryMsg = source._binaryMsg
      _mentionPids = source._mentionPids
      _mentionAll = source._mentionAll
      _convType = source._convType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._msg)
        case 2: try decoder.decodeSingularStringField(value: &_storage._uid)
        case 3: try decoder.decodeSingularStringField(value: &_storage._fromPeerID)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._timestamp)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._offline)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._hasMore_p)
        case 7: try decoder.decodeRepeatedStringField(value: &_storage._toPeerIds)
        case 10: try decoder.decodeSingularBoolField(value: &_storage._r)
        case 11: try decoder.decodeSingularStringField(value: &_storage._cid)
        case 12: try decoder.decodeSingularStringField(value: &_storage._id)
        case 13: try decoder.decodeSingularBoolField(value: &_storage._transient)
        case 14: try decoder.decodeSingularStringField(value: &_storage._dt)
        case 15: try decoder.decodeSingularStringField(value: &_storage._roomID)
        case 16: try decoder.decodeSingularStringField(value: &_storage._pushData)
        case 17: try decoder.decodeSingularBoolField(value: &_storage._will)
        case 18: try decoder.decodeSingularInt64Field(value: &_storage._patchTimestamp)
        case 19: try decoder.decodeSingularBytesField(value: &_storage._binaryMsg)
        case 20: try decoder.decodeRepeatedStringField(value: &_storage._mentionPids)
        case 21: try decoder.decodeSingularBoolField(value: &_storage._mentionAll)
        case 22: try decoder.decodeSingularInt32Field(value: &_storage._convType)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._msg {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._uid {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._fromPeerID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._timestamp {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
      }
      if let v = _storage._offline {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      }
      if let v = _storage._hasMore_p {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      }
      if !_storage._toPeerIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._toPeerIds, fieldNumber: 7)
      }
      if let v = _storage._r {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      }
      if let v = _storage._cid {
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      }
      if let v = _storage._id {
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      }
      if let v = _storage._transient {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      }
      if let v = _storage._dt {
        try visitor.visitSingularStringField(value: v, fieldNumber: 14)
      }
      if let v = _storage._roomID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 15)
      }
      if let v = _storage._pushData {
        try visitor.visitSingularStringField(value: v, fieldNumber: 16)
      }
      if let v = _storage._will {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
      }
      if let v = _storage._patchTimestamp {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 18)
      }
      if let v = _storage._binaryMsg {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 19)
      }
      if !_storage._mentionPids.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._mentionPids, fieldNumber: 20)
      }
      if let v = _storage._mentionAll {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 21)
      }
      if let v = _storage._convType {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 22)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IMDirectCommand, rhs: IMDirectCommand) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._msg != rhs_storage._msg {return false}
        if _storage._uid != rhs_storage._uid {return false}
        if _storage._fromPeerID != rhs_storage._fromPeerID {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._offline != rhs_storage._offline {return false}
        if _storage._hasMore_p != rhs_storage._hasMore_p {return false}
        if _storage._toPeerIds != rhs_storage._toPeerIds {return false}
        if _storage._r != rhs_storage._r {return false}
        if _storage._cid != rhs_storage._cid {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._transient != rhs_storage._transient {return false}
        if _storage._dt != rhs_storage._dt {return false}
        if _storage._roomID != rhs_storage._roomID {return false}
        if _storage._pushData != rhs_storage._pushData {return false}
        if _storage._will != rhs_storage._will {return false}
        if _storage._patchTimestamp != rhs_storage._patchTimestamp {return false}
        if _storage._binaryMsg != rhs_storage._binaryMsg {return false}
        if _storage._mentionPids != rhs_storage._mentionPids {return false}
        if _storage._mentionAll != rhs_storage._mentionAll {return false}
        if _storage._convType != rhs_storage._convType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMAckCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AckCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "reason"),
    3: .same(proto: "mid"),
    4: .same(proto: "cid"),
    5: .same(proto: "t"),
    6: .same(proto: "uid"),
    7: .same(proto: "fromts"),
    8: .same(proto: "tots"),
    9: .same(proto: "type"),
    10: .same(proto: "ids"),
    11: .same(proto: "appCode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self._code)
      case 2: try decoder.decodeSingularStringField(value: &self._reason)
      case 3: try decoder.decodeSingularStringField(value: &self._mid)
      case 4: try decoder.decodeSingularStringField(value: &self._cid)
      case 5: try decoder.decodeSingularInt64Field(value: &self._t)
      case 6: try decoder.decodeSingularStringField(value: &self._uid)
      case 7: try decoder.decodeSingularInt64Field(value: &self._fromts)
      case 8: try decoder.decodeSingularInt64Field(value: &self._tots)
      case 9: try decoder.decodeSingularStringField(value: &self._type)
      case 10: try decoder.decodeRepeatedStringField(value: &self.ids)
      case 11: try decoder.decodeSingularInt32Field(value: &self._appCode)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._code {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._reason {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._mid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._cid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._t {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    }
    if let v = self._uid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if let v = self._fromts {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 7)
    }
    if let v = self._tots {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 8)
    }
    if let v = self._type {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    }
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 10)
    }
    if let v = self._appCode {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IMAckCommand, rhs: IMAckCommand) -> Bool {
    if lhs._code != rhs._code {return false}
    if lhs._reason != rhs._reason {return false}
    if lhs._mid != rhs._mid {return false}
    if lhs._cid != rhs._cid {return false}
    if lhs._t != rhs._t {return false}
    if lhs._uid != rhs._uid {return false}
    if lhs._fromts != rhs._fromts {return false}
    if lhs._tots != rhs._tots {return false}
    if lhs._type != rhs._type {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs._appCode != rhs._appCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMUnreadCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnreadCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "convs"),
    2: .same(proto: "notifTime"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.convs) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.convs)
      case 2: try decoder.decodeSingularInt64Field(value: &self._notifTime)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.convs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.convs, fieldNumber: 1)
    }
    if let v = self._notifTime {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IMUnreadCommand, rhs: IMUnreadCommand) -> Bool {
    if lhs.convs != rhs.convs {return false}
    if lhs._notifTime != rhs._notifTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMConvCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConvCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "m"),
    2: .same(proto: "transient"),
    3: .same(proto: "unique"),
    4: .same(proto: "cid"),
    5: .same(proto: "cdate"),
    6: .same(proto: "initBy"),
    7: .same(proto: "sort"),
    8: .same(proto: "limit"),
    9: .same(proto: "skip"),
    10: .same(proto: "flag"),
    11: .same(proto: "count"),
    12: .same(proto: "udate"),
    13: .same(proto: "t"),
    14: .same(proto: "n"),
    15: .same(proto: "s"),
    16: .same(proto: "statusSub"),
    17: .same(proto: "statusPub"),
    18: .same(proto: "statusTTL"),
    19: .same(proto: "uniqueId"),
    20: .same(proto: "targetClientId"),
    21: .same(proto: "maxReadTimestamp"),
    22: .same(proto: "maxAckTimestamp"),
    23: .same(proto: "queryAllMembers"),
    24: .same(proto: "maxReadTuples"),
    25: .same(proto: "cids"),
    26: .same(proto: "info"),
    27: .same(proto: "tempConv"),
    28: .same(proto: "tempConvTTL"),
    29: .same(proto: "tempConvIds"),
    30: .same(proto: "allowedPids"),
    31: .same(proto: "failedPids"),
    40: .same(proto: "next"),
    100: .same(proto: "results"),
    101: .same(proto: "where"),
    103: .same(proto: "attr"),
    104: .same(proto: "attrModified"),
  ]

  fileprivate class _StorageClass {
    var _m: [String] = []
    var _transient: Bool? = nil
    var _unique: Bool? = nil
    var _cid: String? = nil
    var _cdate: String? = nil
    var _initBy: String? = nil
    var _sort: String? = nil
    var _limit: Int32? = nil
    var _skip: Int32? = nil
    var _flag: Int32? = nil
    var _count: Int32? = nil
    var _udate: String? = nil
    var _t: Int64? = nil
    var _n: String? = nil
    var _s: String? = nil
    var _statusSub: Bool? = nil
    var _statusPub: Bool? = nil
    var _statusTtl: Int32? = nil
    var _uniqueID: String? = nil
    var _targetClientID: String? = nil
    var _maxReadTimestamp: Int64? = nil
    var _maxAckTimestamp: Int64? = nil
    var _queryAllMembers: Bool? = nil
    var _maxReadTuples: [IMMaxReadTuple] = []
    var _cids: [String] = []
    var _info: IMConvMemberInfo? = nil
    var _tempConv: Bool? = nil
    var _tempConvTtl: Int32? = nil
    var _tempConvIds: [String] = []
    var _allowedPids: [String] = []
    var _failedPids: [IMErrorCommand] = []
    var _next: String? = nil
    var _results: IMJsonObjectMessage? = nil
    var _where: IMJsonObjectMessage? = nil
    var _attr: IMJsonObjectMessage? = nil
    var _attrModified: IMJsonObjectMessage? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _m = source._m
      _transient = source._transient
      _unique = source._unique
      _cid = source._cid
      _cdate = source._cdate
      _initBy = source._initBy
      _sort = source._sort
      _limit = source._limit
      _skip = source._skip
      _flag = source._flag
      _count = source._count
      _udate = source._udate
      _t = source._t
      _n = source._n
      _s = source._s
      _statusSub = source._statusSub
      _statusPub = source._statusPub
      _statusTtl = source._statusTtl
      _uniqueID = source._uniqueID
      _targetClientID = source._targetClientID
      _maxReadTimestamp = source._maxReadTimestamp
      _maxAckTimestamp = source._maxAckTimestamp
      _queryAllMembers = source._queryAllMembers
      _maxReadTuples = source._maxReadTuples
      _cids = source._cids
      _info = source._info
      _tempConv = source._tempConv
      _tempConvTtl = source._tempConvTtl
      _tempConvIds = source._tempConvIds
      _allowedPids = source._allowedPids
      _failedPids = source._failedPids
      _next = source._next
      _results = source._results
      _where = source._where
      _attr = source._attr
      _attrModified = source._attrModified
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._failedPids) {return false}
      if let v = _storage._results, !v.isInitialized {return false}
      if let v = _storage._where, !v.isInitialized {return false}
      if let v = _storage._attr, !v.isInitialized {return false}
      if let v = _storage._attrModified, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedStringField(value: &_storage._m)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._transient)
        case 3: try decoder.decodeSingularBoolField(value: &_storage._unique)
        case 4: try decoder.decodeSingularStringField(value: &_storage._cid)
        case 5: try decoder.decodeSingularStringField(value: &_storage._cdate)
        case 6: try decoder.decodeSingularStringField(value: &_storage._initBy)
        case 7: try decoder.decodeSingularStringField(value: &_storage._sort)
        case 8: try decoder.decodeSingularInt32Field(value: &_storage._limit)
        case 9: try decoder.decodeSingularInt32Field(value: &_storage._skip)
        case 10: try decoder.decodeSingularInt32Field(value: &_storage._flag)
        case 11: try decoder.decodeSingularInt32Field(value: &_storage._count)
        case 12: try decoder.decodeSingularStringField(value: &_storage._udate)
        case 13: try decoder.decodeSingularInt64Field(value: &_storage._t)
        case 14: try decoder.decodeSingularStringField(value: &_storage._n)
        case 15: try decoder.decodeSingularStringField(value: &_storage._s)
        case 16: try decoder.decodeSingularBoolField(value: &_storage._statusSub)
        case 17: try decoder.decodeSingularBoolField(value: &_storage._statusPub)
        case 18: try decoder.decodeSingularInt32Field(value: &_storage._statusTtl)
        case 19: try decoder.decodeSingularStringField(value: &_storage._uniqueID)
        case 20: try decoder.decodeSingularStringField(value: &_storage._targetClientID)
        case 21: try decoder.decodeSingularInt64Field(value: &_storage._maxReadTimestamp)
        case 22: try decoder.decodeSingularInt64Field(value: &_storage._maxAckTimestamp)
        case 23: try decoder.decodeSingularBoolField(value: &_storage._queryAllMembers)
        case 24: try decoder.decodeRepeatedMessageField(value: &_storage._maxReadTuples)
        case 25: try decoder.decodeRepeatedStringField(value: &_storage._cids)
        case 26: try decoder.decodeSingularMessageField(value: &_storage._info)
        case 27: try decoder.decodeSingularBoolField(value: &_storage._tempConv)
        case 28: try decoder.decodeSingularInt32Field(value: &_storage._tempConvTtl)
        case 29: try decoder.decodeRepeatedStringField(value: &_storage._tempConvIds)
        case 30: try decoder.decodeRepeatedStringField(value: &_storage._allowedPids)
        case 31: try decoder.decodeRepeatedMessageField(value: &_storage._failedPids)
        case 40: try decoder.decodeSingularStringField(value: &_storage._next)
        case 100: try decoder.decodeSingularMessageField(value: &_storage._results)
        case 101: try decoder.decodeSingularMessageField(value: &_storage._where)
        case 103: try decoder.decodeSingularMessageField(value: &_storage._attr)
        case 104: try decoder.decodeSingularMessageField(value: &_storage._attrModified)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._m.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._m, fieldNumber: 1)
      }
      if let v = _storage._transient {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      }
      if let v = _storage._unique {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      }
      if let v = _storage._cid {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._cdate {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._initBy {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._sort {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      }
      if let v = _storage._limit {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
      }
      if let v = _storage._skip {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 9)
      }
      if let v = _storage._flag {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
      }
      if let v = _storage._count {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 11)
      }
      if let v = _storage._udate {
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      }
      if let v = _storage._t {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 13)
      }
      if let v = _storage._n {
        try visitor.visitSingularStringField(value: v, fieldNumber: 14)
      }
      if let v = _storage._s {
        try visitor.visitSingularStringField(value: v, fieldNumber: 15)
      }
      if let v = _storage._statusSub {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
      }
      if let v = _storage._statusPub {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
      }
      if let v = _storage._statusTtl {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 18)
      }
      if let v = _storage._uniqueID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 19)
      }
      if let v = _storage._targetClientID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 20)
      }
      if let v = _storage._maxReadTimestamp {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 21)
      }
      if let v = _storage._maxAckTimestamp {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 22)
      }
      if let v = _storage._queryAllMembers {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 23)
      }
      if !_storage._maxReadTuples.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._maxReadTuples, fieldNumber: 24)
      }
      if !_storage._cids.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._cids, fieldNumber: 25)
      }
      if let v = _storage._info {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }
      if let v = _storage._tempConv {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 27)
      }
      if let v = _storage._tempConvTtl {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 28)
      }
      if !_storage._tempConvIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._tempConvIds, fieldNumber: 29)
      }
      if !_storage._allowedPids.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._allowedPids, fieldNumber: 30)
      }
      if !_storage._failedPids.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._failedPids, fieldNumber: 31)
      }
      if let v = _storage._next {
        try visitor.visitSingularStringField(value: v, fieldNumber: 40)
      }
      if let v = _storage._results {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
      }
      if let v = _storage._where {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
      }
      if let v = _storage._attr {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
      }
      if let v = _storage._attrModified {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IMConvCommand, rhs: IMConvCommand) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._m != rhs_storage._m {return false}
        if _storage._transient != rhs_storage._transient {return false}
        if _storage._unique != rhs_storage._unique {return false}
        if _storage._cid != rhs_storage._cid {return false}
        if _storage._cdate != rhs_storage._cdate {return false}
        if _storage._initBy != rhs_storage._initBy {return false}
        if _storage._sort != rhs_storage._sort {return false}
        if _storage._limit != rhs_storage._limit {return false}
        if _storage._skip != rhs_storage._skip {return false}
        if _storage._flag != rhs_storage._flag {return false}
        if _storage._count != rhs_storage._count {return false}
        if _storage._udate != rhs_storage._udate {return false}
        if _storage._t != rhs_storage._t {return false}
        if _storage._n != rhs_storage._n {return false}
        if _storage._s != rhs_storage._s {return false}
        if _storage._statusSub != rhs_storage._statusSub {return false}
        if _storage._statusPub != rhs_storage._statusPub {return false}
        if _storage._statusTtl != rhs_storage._statusTtl {return false}
        if _storage._uniqueID != rhs_storage._uniqueID {return false}
        if _storage._targetClientID != rhs_storage._targetClientID {return false}
        if _storage._maxReadTimestamp != rhs_storage._maxReadTimestamp {return false}
        if _storage._maxAckTimestamp != rhs_storage._maxAckTimestamp {return false}
        if _storage._queryAllMembers != rhs_storage._queryAllMembers {return false}
        if _storage._maxReadTuples != rhs_storage._maxReadTuples {return false}
        if _storage._cids != rhs_storage._cids {return false}
        if _storage._info != rhs_storage._info {return false}
        if _storage._tempConv != rhs_storage._tempConv {return false}
        if _storage._tempConvTtl != rhs_storage._tempConvTtl {return false}
        if _storage._tempConvIds != rhs_storage._tempConvIds {return false}
        if _storage._allowedPids != rhs_storage._allowedPids {return false}
        if _storage._failedPids != rhs_storage._failedPids {return false}
        if _storage._next != rhs_storage._next {return false}
        if _storage._results != rhs_storage._results {return false}
        if _storage._where != rhs_storage._where {return false}
        if _storage._attr != rhs_storage._attr {return false}
        if _storage._attrModified != rhs_storage._attrModified {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMRoomCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RoomCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "roomId"),
    2: .same(proto: "s"),
    3: .same(proto: "t"),
    4: .same(proto: "n"),
    5: .same(proto: "transient"),
    6: .same(proto: "roomPeerIds"),
    7: .same(proto: "byPeerId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._roomID)
      case 2: try decoder.decodeSingularStringField(value: &self._s)
      case 3: try decoder.decodeSingularInt64Field(value: &self._t)
      case 4: try decoder.decodeSingularStringField(value: &self._n)
      case 5: try decoder.decodeSingularBoolField(value: &self._transient)
      case 6: try decoder.decodeRepeatedStringField(value: &self.roomPeerIds)
      case 7: try decoder.decodeSingularStringField(value: &self._byPeerID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._roomID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._s {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._t {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }
    if let v = self._n {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._transient {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    if !self.roomPeerIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roomPeerIds, fieldNumber: 6)
    }
    if let v = self._byPeerID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IMRoomCommand, rhs: IMRoomCommand) -> Bool {
    if lhs._roomID != rhs._roomID {return false}
    if lhs._s != rhs._s {return false}
    if lhs._t != rhs._t {return false}
    if lhs._n != rhs._n {return false}
    if lhs._transient != rhs._transient {return false}
    if lhs.roomPeerIds != rhs.roomPeerIds {return false}
    if lhs._byPeerID != rhs._byPeerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMLogsCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LogsCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cid"),
    2: .same(proto: "l"),
    3: .same(proto: "limit"),
    4: .same(proto: "t"),
    5: .same(proto: "tt"),
    6: .same(proto: "tmid"),
    7: .same(proto: "mid"),
    8: .same(proto: "checksum"),
    9: .same(proto: "stored"),
    10: .same(proto: "direction"),
    11: .same(proto: "tIncluded"),
    12: .same(proto: "ttIncluded"),
    13: .same(proto: "lctype"),
    105: .same(proto: "logs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._cid)
      case 2: try decoder.decodeSingularInt32Field(value: &self._l)
      case 3: try decoder.decodeSingularInt32Field(value: &self._limit)
      case 4: try decoder.decodeSingularInt64Field(value: &self._t)
      case 5: try decoder.decodeSingularInt64Field(value: &self._tt)
      case 6: try decoder.decodeSingularStringField(value: &self._tmid)
      case 7: try decoder.decodeSingularStringField(value: &self._mid)
      case 8: try decoder.decodeSingularStringField(value: &self._checksum)
      case 9: try decoder.decodeSingularBoolField(value: &self._stored)
      case 10: try decoder.decodeSingularEnumField(value: &self._direction)
      case 11: try decoder.decodeSingularBoolField(value: &self._tIncluded)
      case 12: try decoder.decodeSingularBoolField(value: &self._ttIncluded)
      case 13: try decoder.decodeSingularInt32Field(value: &self._lctype)
      case 105: try decoder.decodeRepeatedMessageField(value: &self.logs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._cid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._l {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._limit {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._t {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    }
    if let v = self._tt {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
    }
    if let v = self._tmid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if let v = self._mid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }
    if let v = self._checksum {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    }
    if let v = self._stored {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    }
    if let v = self._direction {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
    }
    if let v = self._tIncluded {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
    }
    if let v = self._ttIncluded {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
    }
    if let v = self._lctype {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 13)
    }
    if !self.logs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logs, fieldNumber: 105)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IMLogsCommand, rhs: IMLogsCommand) -> Bool {
    if lhs._cid != rhs._cid {return false}
    if lhs._l != rhs._l {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs._t != rhs._t {return false}
    if lhs._tt != rhs._tt {return false}
    if lhs._tmid != rhs._tmid {return false}
    if lhs._mid != rhs._mid {return false}
    if lhs._checksum != rhs._checksum {return false}
    if lhs._stored != rhs._stored {return false}
    if lhs._direction != rhs._direction {return false}
    if lhs._tIncluded != rhs._tIncluded {return false}
    if lhs._ttIncluded != rhs._ttIncluded {return false}
    if lhs._lctype != rhs._lctype {return false}
    if lhs.logs != rhs.logs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMLogsCommand.QueryDirection: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "OLD"),
    2: .same(proto: "NEW"),
  ]
}

extension IMRcpCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RcpCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "cid"),
    3: .same(proto: "t"),
    4: .same(proto: "read"),
    5: .same(proto: "from"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._id)
      case 2: try decoder.decodeSingularStringField(value: &self._cid)
      case 3: try decoder.decodeSingularInt64Field(value: &self._t)
      case 4: try decoder.decodeSingularBoolField(value: &self._read)
      case 5: try decoder.decodeSingularStringField(value: &self._from)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._cid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._t {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }
    if let v = self._read {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if let v = self._from {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IMRcpCommand, rhs: IMRcpCommand) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._cid != rhs._cid {return false}
    if lhs._t != rhs._t {return false}
    if lhs._read != rhs._read {return false}
    if lhs._from != rhs._from {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMReadTuple: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadTuple"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cid"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "mid"),
  ]

  public var isInitialized: Bool {
    if self._cid == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._cid)
      case 2: try decoder.decodeSingularInt64Field(value: &self._timestamp)
      case 3: try decoder.decodeSingularStringField(value: &self._mid)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._cid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._timestamp {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }
    if let v = self._mid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IMReadTuple, rhs: IMReadTuple) -> Bool {
    if lhs._cid != rhs._cid {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._mid != rhs._mid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMMaxReadTuple: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MaxReadTuple"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pid"),
    2: .same(proto: "maxAckTimestamp"),
    3: .same(proto: "maxReadTimestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._pid)
      case 2: try decoder.decodeSingularInt64Field(value: &self._maxAckTimestamp)
      case 3: try decoder.decodeSingularInt64Field(value: &self._maxReadTimestamp)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._pid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._maxAckTimestamp {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }
    if let v = self._maxReadTimestamp {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IMMaxReadTuple, rhs: IMMaxReadTuple) -> Bool {
    if lhs._pid != rhs._pid {return false}
    if lhs._maxAckTimestamp != rhs._maxAckTimestamp {return false}
    if lhs._maxReadTimestamp != rhs._maxReadTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMReadCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cid"),
    2: .same(proto: "cids"),
    3: .same(proto: "convs"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.convs) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._cid)
      case 2: try decoder.decodeRepeatedStringField(value: &self.cids)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.convs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._cid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.cids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.cids, fieldNumber: 2)
    }
    if !self.convs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.convs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IMReadCommand, rhs: IMReadCommand) -> Bool {
    if lhs._cid != rhs._cid {return false}
    if lhs.cids != rhs.cids {return false}
    if lhs.convs != rhs.convs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMPresenceCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PresenceCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "sessionPeerIds"),
    3: .same(proto: "cid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._status)
      case 2: try decoder.decodeRepeatedStringField(value: &self.sessionPeerIds)
      case 3: try decoder.decodeSingularStringField(value: &self._cid)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if !self.sessionPeerIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.sessionPeerIds, fieldNumber: 2)
    }
    if let v = self._cid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IMPresenceCommand, rhs: IMPresenceCommand) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.sessionPeerIds != rhs.sessionPeerIds {return false}
    if lhs._cid != rhs._cid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMReportCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReportCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "initiative"),
    2: .same(proto: "type"),
    3: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self._initiative)
      case 2: try decoder.decodeSingularStringField(value: &self._type)
      case 3: try decoder.decodeSingularStringField(value: &self._data)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._initiative {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    if let v = self._type {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._data {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IMReportCommand, rhs: IMReportCommand) -> Bool {
    if lhs._initiative != rhs._initiative {return false}
    if lhs._type != rhs._type {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMPatchItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PatchItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cid"),
    2: .same(proto: "mid"),
    3: .same(proto: "timestamp"),
    4: .same(proto: "recall"),
    5: .same(proto: "data"),
    6: .same(proto: "patchTimestamp"),
    7: .same(proto: "from"),
    8: .same(proto: "binaryMsg"),
    9: .same(proto: "mentionAll"),
    10: .same(proto: "mentionPids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._cid)
      case 2: try decoder.decodeSingularStringField(value: &self._mid)
      case 3: try decoder.decodeSingularInt64Field(value: &self._timestamp)
      case 4: try decoder.decodeSingularBoolField(value: &self._recall)
      case 5: try decoder.decodeSingularStringField(value: &self._data)
      case 6: try decoder.decodeSingularInt64Field(value: &self._patchTimestamp)
      case 7: try decoder.decodeSingularStringField(value: &self._from)
      case 8: try decoder.decodeSingularBytesField(value: &self._binaryMsg)
      case 9: try decoder.decodeSingularBoolField(value: &self._mentionAll)
      case 10: try decoder.decodeRepeatedStringField(value: &self.mentionPids)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._cid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._mid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._timestamp {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }
    if let v = self._recall {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if let v = self._data {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._patchTimestamp {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 6)
    }
    if let v = self._from {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }
    if let v = self._binaryMsg {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
    }
    if let v = self._mentionAll {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    }
    if !self.mentionPids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.mentionPids, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IMPatchItem, rhs: IMPatchItem) -> Bool {
    if lhs._cid != rhs._cid {return false}
    if lhs._mid != rhs._mid {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._recall != rhs._recall {return false}
    if lhs._data != rhs._data {return false}
    if lhs._patchTimestamp != rhs._patchTimestamp {return false}
    if lhs._from != rhs._from {return false}
    if lhs._binaryMsg != rhs._binaryMsg {return false}
    if lhs._mentionAll != rhs._mentionAll {return false}
    if lhs.mentionPids != rhs.mentionPids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMPatchCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PatchCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "patches"),
    2: .same(proto: "lastPatchTime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.patches)
      case 2: try decoder.decodeSingularInt64Field(value: &self._lastPatchTime)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.patches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.patches, fieldNumber: 1)
    }
    if let v = self._lastPatchTime {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IMPatchCommand, rhs: IMPatchCommand) -> Bool {
    if lhs.patches != rhs.patches {return false}
    if lhs._lastPatchTime != rhs._lastPatchTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMPubsubCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PubsubCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cid"),
    2: .same(proto: "cids"),
    3: .same(proto: "topic"),
    4: .same(proto: "subtopic"),
    5: .same(proto: "topics"),
    6: .same(proto: "subtopics"),
    7: .same(proto: "results"),
  ]

  fileprivate class _StorageClass {
    var _cid: String? = nil
    var _cids: [String] = []
    var _topic: String? = nil
    var _subtopic: String? = nil
    var _topics: [String] = []
    var _subtopics: [String] = []
    var _results: IMJsonObjectMessage? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _cid = source._cid
      _cids = source._cids
      _topic = source._topic
      _subtopic = source._subtopic
      _topics = source._topics
      _subtopics = source._subtopics
      _results = source._results
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._results, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._cid)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._cids)
        case 3: try decoder.decodeSingularStringField(value: &_storage._topic)
        case 4: try decoder.decodeSingularStringField(value: &_storage._subtopic)
        case 5: try decoder.decodeRepeatedStringField(value: &_storage._topics)
        case 6: try decoder.decodeRepeatedStringField(value: &_storage._subtopics)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._results)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._cid {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if !_storage._cids.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._cids, fieldNumber: 2)
      }
      if let v = _storage._topic {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._subtopic {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if !_storage._topics.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._topics, fieldNumber: 5)
      }
      if !_storage._subtopics.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._subtopics, fieldNumber: 6)
      }
      if let v = _storage._results {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IMPubsubCommand, rhs: IMPubsubCommand) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._cid != rhs_storage._cid {return false}
        if _storage._cids != rhs_storage._cids {return false}
        if _storage._topic != rhs_storage._topic {return false}
        if _storage._subtopic != rhs_storage._subtopic {return false}
        if _storage._topics != rhs_storage._topics {return false}
        if _storage._subtopics != rhs_storage._subtopics {return false}
        if _storage._results != rhs_storage._results {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMBlacklistCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlacklistCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "srcCid"),
    2: .same(proto: "toPids"),
    3: .same(proto: "srcPid"),
    4: .same(proto: "toCids"),
    5: .same(proto: "limit"),
    6: .same(proto: "next"),
    8: .same(proto: "blockedPids"),
    9: .same(proto: "blockedCids"),
    10: .same(proto: "allowedPids"),
    11: .same(proto: "failedPids"),
    12: .same(proto: "t"),
    13: .same(proto: "n"),
    14: .same(proto: "s"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.failedPids) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._srcCid)
      case 2: try decoder.decodeRepeatedStringField(value: &self.toPids)
      case 3: try decoder.decodeSingularStringField(value: &self._srcPid)
      case 4: try decoder.decodeRepeatedStringField(value: &self.toCids)
      case 5: try decoder.decodeSingularInt32Field(value: &self._limit)
      case 6: try decoder.decodeSingularStringField(value: &self._next)
      case 8: try decoder.decodeRepeatedStringField(value: &self.blockedPids)
      case 9: try decoder.decodeRepeatedStringField(value: &self.blockedCids)
      case 10: try decoder.decodeRepeatedStringField(value: &self.allowedPids)
      case 11: try decoder.decodeRepeatedMessageField(value: &self.failedPids)
      case 12: try decoder.decodeSingularInt64Field(value: &self._t)
      case 13: try decoder.decodeSingularStringField(value: &self._n)
      case 14: try decoder.decodeSingularStringField(value: &self._s)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._srcCid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if !self.toPids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.toPids, fieldNumber: 2)
    }
    if let v = self._srcPid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if !self.toCids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.toCids, fieldNumber: 4)
    }
    if let v = self._limit {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._next {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if !self.blockedPids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.blockedPids, fieldNumber: 8)
    }
    if !self.blockedCids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.blockedCids, fieldNumber: 9)
    }
    if !self.allowedPids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedPids, fieldNumber: 10)
    }
    if !self.failedPids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.failedPids, fieldNumber: 11)
    }
    if let v = self._t {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 12)
    }
    if let v = self._n {
      try visitor.visitSingularStringField(value: v, fieldNumber: 13)
    }
    if let v = self._s {
      try visitor.visitSingularStringField(value: v, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IMBlacklistCommand, rhs: IMBlacklistCommand) -> Bool {
    if lhs._srcCid != rhs._srcCid {return false}
    if lhs.toPids != rhs.toPids {return false}
    if lhs._srcPid != rhs._srcPid {return false}
    if lhs.toCids != rhs.toCids {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs._next != rhs._next {return false}
    if lhs.blockedPids != rhs.blockedPids {return false}
    if lhs.blockedCids != rhs.blockedCids {return false}
    if lhs.allowedPids != rhs.allowedPids {return false}
    if lhs.failedPids != rhs.failedPids {return false}
    if lhs._t != rhs._t {return false}
    if lhs._n != rhs._n {return false}
    if lhs._s != rhs._s {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IMGenericCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenericCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cmd"),
    2: .same(proto: "op"),
    3: .same(proto: "appId"),
    4: .same(proto: "peerId"),
    5: .same(proto: "i"),
    6: .same(proto: "installationId"),
    7: .same(proto: "priority"),
    8: .same(proto: "service"),
    9: .same(proto: "serverTs"),
    101: .same(proto: "dataMessage"),
    102: .same(proto: "sessionMessage"),
    103: .same(proto: "errorMessage"),
    104: .same(proto: "directMessage"),
    105: .same(proto: "ackMessage"),
    106: .same(proto: "unreadMessage"),
    107: .same(proto: "readMessage"),
    108: .same(proto: "rcpMessage"),
    109: .same(proto: "logsMessage"),
    110: .same(proto: "convMessage"),
    111: .same(proto: "roomMessage"),
    112: .same(proto: "presenceMessage"),
    113: .same(proto: "reportMessage"),
    114: .same(proto: "patchMessage"),
    115: .same(proto: "pubsubMessage"),
    116: .same(proto: "blacklistMessage"),
  ]

  fileprivate class _StorageClass {
    var _cmd: IMCommandType? = nil
    var _op: IMOpType? = nil
    var _appID: String? = nil
    var _peerID: String? = nil
    var _i: Int32? = nil
    var _installationID: String? = nil
    var _priority: Int32? = nil
    var _service: Int32? = nil
    var _serverTs: Int64? = nil
    var _dataMessage: IMDataCommand? = nil
    var _sessionMessage: IMSessionCommand? = nil
    var _errorMessage: IMErrorCommand? = nil
    var _directMessage: IMDirectCommand? = nil
    var _ackMessage: IMAckCommand? = nil
    var _unreadMessage: IMUnreadCommand? = nil
    var _readMessage: IMReadCommand? = nil
    var _rcpMessage: IMRcpCommand? = nil
    var _logsMessage: IMLogsCommand? = nil
    var _convMessage: IMConvCommand? = nil
    var _roomMessage: IMRoomCommand? = nil
    var _presenceMessage: IMPresenceCommand? = nil
    var _reportMessage: IMReportCommand? = nil
    var _patchMessage: IMPatchCommand? = nil
    var _pubsubMessage: IMPubsubCommand? = nil
    var _blacklistMessage: IMBlacklistCommand? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _cmd = source._cmd
      _op = source._op
      _appID = source._appID
      _peerID = source._peerID
      _i = source._i
      _installationID = source._installationID
      _priority = source._priority
      _service = source._service
      _serverTs = source._serverTs
      _dataMessage = source._dataMessage
      _sessionMessage = source._sessionMessage
      _errorMessage = source._errorMessage
      _directMessage = source._directMessage
      _ackMessage = source._ackMessage
      _unreadMessage = source._unreadMessage
      _readMessage = source._readMessage
      _rcpMessage = source._rcpMessage
      _logsMessage = source._logsMessage
      _convMessage = source._convMessage
      _roomMessage = source._roomMessage
      _presenceMessage = source._presenceMessage
      _reportMessage = source._reportMessage
      _patchMessage = source._patchMessage
      _pubsubMessage = source._pubsubMessage
      _blacklistMessage = source._blacklistMessage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._dataMessage, !v.isInitialized {return false}
      if let v = _storage._errorMessage, !v.isInitialized {return false}
      if let v = _storage._unreadMessage, !v.isInitialized {return false}
      if let v = _storage._readMessage, !v.isInitialized {return false}
      if let v = _storage._convMessage, !v.isInitialized {return false}
      if let v = _storage._pubsubMessage, !v.isInitialized {return false}
      if let v = _storage._blacklistMessage, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._cmd)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._op)
        case 3: try decoder.decodeSingularStringField(value: &_storage._appID)
        case 4: try decoder.decodeSingularStringField(value: &_storage._peerID)
        case 5: try decoder.decodeSingularInt32Field(value: &_storage._i)
        case 6: try decoder.decodeSingularStringField(value: &_storage._installationID)
        case 7: try decoder.decodeSingularInt32Field(value: &_storage._priority)
        case 8: try decoder.decodeSingularInt32Field(value: &_storage._service)
        case 9: try decoder.decodeSingularInt64Field(value: &_storage._serverTs)
        case 101: try decoder.decodeSingularMessageField(value: &_storage._dataMessage)
        case 102: try decoder.decodeSingularMessageField(value: &_storage._sessionMessage)
        case 103: try decoder.decodeSingularMessageField(value: &_storage._errorMessage)
        case 104: try decoder.decodeSingularMessageField(value: &_storage._directMessage)
        case 105: try decoder.decodeSingularMessageField(value: &_storage._ackMessage)
        case 106: try decoder.decodeSingularMessageField(value: &_storage._unreadMessage)
        case 107: try decoder.decodeSingularMessageField(value: &_storage._readMessage)
        case 108: try decoder.decodeSingularMessageField(value: &_storage._rcpMessage)
        case 109: try decoder.decodeSingularMessageField(value: &_storage._logsMessage)
        case 110: try decoder.decodeSingularMessageField(value: &_storage._convMessage)
        case 111: try decoder.decodeSingularMessageField(value: &_storage._roomMessage)
        case 112: try decoder.decodeSingularMessageField(value: &_storage._presenceMessage)
        case 113: try decoder.decodeSingularMessageField(value: &_storage._reportMessage)
        case 114: try decoder.decodeSingularMessageField(value: &_storage._patchMessage)
        case 115: try decoder.decodeSingularMessageField(value: &_storage._pubsubMessage)
        case 116: try decoder.decodeSingularMessageField(value: &_storage._blacklistMessage)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._cmd {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      }
      if let v = _storage._op {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      }
      if let v = _storage._appID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._peerID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._i {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
      }
      if let v = _storage._installationID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._priority {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
      }
      if let v = _storage._service {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
      }
      if let v = _storage._serverTs {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 9)
      }
      if let v = _storage._dataMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
      }
      if let v = _storage._sessionMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
      }
      if let v = _storage._errorMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
      }
      if let v = _storage._directMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
      }
      if let v = _storage._ackMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
      }
      if let v = _storage._unreadMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
      }
      if let v = _storage._readMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
      }
      if let v = _storage._rcpMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
      }
      if let v = _storage._logsMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 109)
      }
      if let v = _storage._convMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 110)
      }
      if let v = _storage._roomMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 111)
      }
      if let v = _storage._presenceMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 112)
      }
      if let v = _storage._reportMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 113)
      }
      if let v = _storage._patchMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 114)
      }
      if let v = _storage._pubsubMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 115)
      }
      if let v = _storage._blacklistMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 116)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: IMGenericCommand, rhs: IMGenericCommand) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._cmd != rhs_storage._cmd {return false}
        if _storage._op != rhs_storage._op {return false}
        if _storage._appID != rhs_storage._appID {return false}
        if _storage._peerID != rhs_storage._peerID {return false}
        if _storage._i != rhs_storage._i {return false}
        if _storage._installationID != rhs_storage._installationID {return false}
        if _storage._priority != rhs_storage._priority {return false}
        if _storage._service != rhs_storage._service {return false}
        if _storage._serverTs != rhs_storage._serverTs {return false}
        if _storage._dataMessage != rhs_storage._dataMessage {return false}
        if _storage._sessionMessage != rhs_storage._sessionMessage {return false}
        if _storage._errorMessage != rhs_storage._errorMessage {return false}
        if _storage._directMessage != rhs_storage._directMessage {return false}
        if _storage._ackMessage != rhs_storage._ackMessage {return false}
        if _storage._unreadMessage != rhs_storage._unreadMessage {return false}
        if _storage._readMessage != rhs_storage._readMessage {return false}
        if _storage._rcpMessage != rhs_storage._rcpMessage {return false}
        if _storage._logsMessage != rhs_storage._logsMessage {return false}
        if _storage._convMessage != rhs_storage._convMessage {return false}
        if _storage._roomMessage != rhs_storage._roomMessage {return false}
        if _storage._presenceMessage != rhs_storage._presenceMessage {return false}
        if _storage._reportMessage != rhs_storage._reportMessage {return false}
        if _storage._patchMessage != rhs_storage._patchMessage {return false}
        if _storage._pubsubMessage != rhs_storage._pubsubMessage {return false}
        if _storage._blacklistMessage != rhs_storage._blacklistMessage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
